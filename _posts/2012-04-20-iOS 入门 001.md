---
layout: post
category: "iOS"
title:  "iOS 入门"
tags: [iOS,Objectiv-C]
summary: "iOS 入门"
---
#进位制

***
#位运算
* 位运算符可以直接对二进制数位进行操作

##&（按位与）
* 两个对应位都为1则得1，有0则得0按位与可以把某个二进制数位置0任何数位和0按位与结果为0，和1按位与结果不变

>
    3 & 5：
    3   0000 0011
    5   0000 0101
        0000 0001

##|（按位或）
* 两个对应位都为0则得0，有1则得1按位或可以把某个二进制数位置1任何数位和0按位或结果不变，和1按位或结果为1

>
    3 | 5：
    3   0000 0011
    5   0000 0101
        0000 0111

##\^(按位异或)
* 两个对应位相同则得0，不同则得1按位异或可以把某个二进制数位求反任何数位和0按位异或结果不变，和1按位异或，1变为0、0变为1

>
    3 ^ 5：
    3   0000 0011
    5   0000 0101
        0000 0110

##<<(左移位运算符)、>>（右移位运算符）
* 可以把一个数据中的所有二进制为向左或向右移动n个位置，但不会改变参与计算的数字，格式为`num << n`或`num >> n
   `
* 左移操作后，右边的空位置上一定补0

>
    3 << 5
    3   0000 0011
        0110 0000

* 右移操作后，有符号数据左边空位置补符号位，无符号数据左边空位置补0

>
    -48 >> 2
    -48 1101 0000
        1111 0100

* 如果移位操作过程中没有丢失有效数字
	* 左移n位相当于乘以2的n次方
	* 右移n位相当于除以2的n次方

***
#C语言
##占位符

* `%zd`，可以自行调整有符号整数的输出
* `%tu`，可以自行调整无符号整数的输出

***
#Objective-C

***
#C语言与Objective-C
* C语言与OC之间相同数据类型转换时需要`__bridge`桥接

***
#Swift

***
#规范与建议
##代码规范
* 类名首字母大写
* 方法名首字母小写
* 方法名使用驼峰式，通过方法名可以看懂方法的目的
* 属性的定义不要使用无意义的名称
* 注释要写在什么位置？
	* 关键算法，起提示作用
	* 头文件中需要给方法添加比较详细的注释，方法作用、参数说明、返回值说明
* 开闭原则
	* 对外封闭、对内开放

##开发建议
* 建议好好开发

***
#系统
##OS X
* 即Operating System 10的简称
* OS X是darwin核心的UNIX系统，属于BSD分支
* 在10.x部分，10.9之前称为Mac OS X，10.9之后称为OS X
* 苹果官方仅支持Macintosh设备上安装OS X系统

##iOS
* 即iPhone/iPad/iPod Touch Operating System的简称

***
#文件属性
* UNIX使用文件属性决定文件的使用方式，文件使用方式分为读、写、执行三种
* 文件属性分为三组，对应三种不同的用户，分别是
	* 所有者
	* 同组人
	* 其他人
* 文件属性的每一组属性由三个连续字符构成
	* `r`读能力，每组属性第一个
	* `w`写能力，每组属性第二个
	* `x`执行能力，每组属性第三个
	* `-`不具备该位置对应能力
* 文件属性的每一组属性的三个字母可以合并为一个数字
	* `7`:`rwx`
	* `6`:`rw-`
	* `5`:`r-x`
	* `4`:`r--`
	* `3`:`-wx`
	* `2`:`-w-`
	* `1`:`--x`
	* `0`:`---`
* 替换规则为
	* `r`用`4`代替
	* `w`用`2`代替
	* `x`用`1`代替
	* `-`用`0`代替
	* 计算每组数字和

***
#内存
##内存空间/内存地址
###基本概念
* 程序员直接接触的内存地址为 __虚拟内存地址__，而非物理内存地址
* 以32位系统为例，每个进程都对应4GB虚拟内存地址空间，其中0-3GB为 __用户层__ ，3-4GB为 __内核层__
* 程序员可以直接操用户层，用户层无法直接操作内核层
* 虚拟内存地址本身不对应任何物理内存或硬盘文件，因此不能存储数据，必须映射到物理内存或硬盘文件，也即分配内存
* 内存管理的单位是字节，内存映射的基本单位是内存页，一次映射必须是内存页的整数倍
* `getpagesize()`可以获取当前系统内存页一页的大小，通常为4096字节
* 如果不映射而直接使用虚拟内存地址，会引发段错误
* 对内存进行没有权限的操作也会引发段错误

###内存空间区域划分
* __堆区__
	* `new`、`delete`、`malloc()`、`free()`等都在堆区分配和回收内存，堆区内存由程序员手动管理
* __栈区__
	* 存放局部变量、函数形参，由系统自动管理
* __BSS段__
	* 存放未初始化的全局变量，在`main()`之前会自动清零
* __全局区(静态区)__
	* 存放已初始化的全局变量、静态变量
* __只读常量区__
	* 存放常量值、`const`修饰的全局变量，只读，例如C语言字符串的字面值`"abc"`
* __代码区__
	* 存放代码，只读
	* 函数指针的值就是函数在代码区的地址

###申请内存后系统的响应
* 栈
	* 只要栈的剩余空间⼤大于所申请空间,系统将为程序提供内存,否则将报异常提⽰栈溢出* 堆	* 操作系统有⼀一个记录空闲内存地址的链表	* 当系统收到程序的申请时,会遍历该链表，寻找第⼀一个空间⼤大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序	* 由于找到的堆结点的⼤大⼩小不⼀定正好等于申请的⼤大⼩小 系统会⾃自动的将多余的那部分重新放⼊入空闲链表中

###申请大小的限制
* 栈
	* 栈是向低地址扩展的数据结构是⼀一块连续的内存的区域，栈顶的地址和栈的最⼤大容量是系统预先规定好的
* 堆
	* 堆是向⾼高地址扩展的数据结构，是不连续的内存区域，这是由于系统是用链表来存储的空闲内存地址的，⾃自然是不连续的，⽽链表的遍历⽅向是由低地址向⾼地址
	* 堆的⼤大⼩小受限于计算机系统中有效的虚拟内存
* 由此可见，堆获得的空间⽐比较灵活，也⽐比较⼤大

###申请效率
* 栈
	* 由系统自动分配，速度较快
* 堆
	* 速度较慢，容易产生内存碎片，但是使用方便

##malloc()/free()
* `malloc()`一次会映射33个内存页，如果一次申请超过33个内存页，则会映射比33个多一点的内存页(系统不同，值不同)
* `malloc()`分配内存时，会额外存储一些附加"信息，如分配内存的大小值等，因此其分配的内存地址是不连续的
* `free()`只释放虚拟内存地址，将已使用的内存地址标记为未使用，未必会解除映射(最后33个内存页不能接触映射)
* 使用`malloc()`分配内存时不要越界使用，否则会损毁附加数据，影响`free()`

##sbrk()/brk()
>sbrk.c

	#include <stdio.h>
	#include <unistd.h>
	int main(){
		void *p0 = sbkr(1);//分配1字节内存
		void *p1 = sbrk(4);//再分配4字节内存
		sbkr(0);//取当前位置
		sbrk(-1)://释放1字节
		sbrk(4);//全部释放
		return 0;
	}

>brk.c

	#include <stdio.h>
	#include <unistd.h>
	int main(){
		void *p0 = sbrk(0);
		brk(p0 + 1);//分配1字节内存
		brk(p0 + 4);//再分配3字节内存，共4字节
		void *p1 = sbrk(0);
		brk(4);//分配4字节
		void *p2 = sbrk(0);
		brk(8);//分配8字节
		void *p3 = sbrk(0);
		brk(p3);//释放p3
		brk(p0);//全部释放
		return 0;
	}

***
#设备
* 当前在售的设备包括：
* Macintosh
	* Mac Mini
		* Mac Mini
		* Mac Mini Server
	* iMac
		* iMac
		* iMac Retina 5K
	* MacBook
		* MacBook
		* MacBook Pro
			* MacBook Pro
			* MacBook Pro Retina
		* MacBook Air
	* Mac Pro
* iPhone
* iPad
	* iPad
	* iPad Mini
* iPod
	* iPod Touch
	* iPod Nano
	* iPod Classic
	* iPod Shuffle
* Airport
	* Airport Express
	* Airport Capsule
* Apple TV
* Apple Watch
* Apple Mouse
* Magic Mouse
* Magic Trackpad
* SuperDrive
* Apple Keyboard
	* Apple Keyboard
	* Apple Wireless Keyboard
* MagSafe
* And More...

***
#终端
* 即Terminal，Command Line Tool

##VI
* vi是Linux系统中用来记录文字信息的工具，它是在终端窗口中使用的工具，因此也不能使用鼠标
	* gVim是windows下的vi
* 启动vi的命令`vi 文件路径`
* vi中的功能分成三组，每组对应一种工作模式，只有位于某种工作模式下的时候才可以使用对应的功能
	* vi正常模式
		* 在这个模式下可以执行简单命令，每次看哦每日vi的时候都处于正常模式下
	* vi插入模式
		* 在这个模式下可以修改文字内容，在正常模式下输入i进入插入模式，按esc返回正常模式
	* vi命令模式
		* 在这个模式下可以执行复杂命令，在正常模式下输入:进入命令模式，按esc返回正常模式
	* 正常模式可以和任何其他模式进行互相的转换，但插入模式和命令模式不可以互相转换
* 命令模式命令：
	* `e!`放弃修改，从上次的保存开始
	* `q`不保存，退出vi
	* `q!`不保存，强制退出vi
	* `w`保存但不退出vi
	* `m,nw name`从m行到n行的内容保存到name文件中
	* `w file`保存到file文件但不退出vi
	* `w!`强制保存，不退出vi
	* `x`保存，退出vi
	* `wq`保存，退出vi
	* `wq!`保存，强制退出vi
	* 在正常模式下输入`nyy`命令可以把从当前光标所在行开始的连续n行拷贝到剪贴板
	* 在正常模式下输入`ndd`命令可以把从当前光标所在行开始的连续n行剪切到剪贴板
	* 在正常模式下输入`np`命令可以在当前光标所在行的下一行粘贴n次剪贴板中的内容
	* 在正常模式下输入`G`命令可以直接到达文件尾
	* 在正常模式下输入`1G`命令可以直接到达文件头
* 在命令模式下使用set命令可以扩展vi的功能：
	* `set number`显示行号
	* `set ai`
	* `set tabstop=4`设置tab键宽度
	* `syntax on`语法高亮
	* `set autoindent`自动缩进
	* `set smartindent`智能缩进
* ~/.vimrc文件用来记录各种set命令，每次vi启动的时候都会把这个文件中的所有命令执行一遍

##常用UNIX命令
<table>
<tr>
<th>CMD</th>
<th>DES</th>
<th>ARG</th>
</tr>

<tr><th>mkdir dirname</th>
<th>创建一个目录</th><th></th>
</tr>

<tr>
<th>rmdir dirname</th>
<th>删除一个目录</th><th></th>
</tr>

<tr>
<th>mvdir dirname1 dirname2</th>
<th>移动或重命名一个目录

</th><th></th></tr><tr><th>cd dirname
</th><th>改变当前目录

</th><th></th></tr><tr><th>pwd
</th><th>显示当前目录的路径名 

</th><th></th></tr><tr><th rowspan="3" colspan="1">ls 
</th><th rowspan="3" colspan="1">显示当前目录的内容

</th><th>-l 显示详细信息</th></tr><tr>
<th>-a 显示全部内容</th></tr><tr>
<th>-la 显示全部内容的详细信息</th>

<tr><th>dircmp dirname1 dirname2
</th><th>比较两个目录的内容

</th><th></th></tr><tr><th>cat filename
</th><th>显示或连接文件

</th><th></th></tr><tr><th>pg filename
</th><th>分页格式化显示文件内容

</th><th></th></tr><tr><th>more filename
</th><th>分屏显示文件内容

</th><th></th></tr><tr><th>od -c filename
</th><th>显示非文本文件的内容

</th><th></th></tr><tr><th>cp filename1 filename2
</th><th>复制文件或目录

</th><th></th></tr><tr><th>rm filename
</th><th>删除文件或目录 

</th><th></th></tr><tr><th>mv filename1 filename2
</th><th>改变文件名或所在目录

</th><th></th></tr><tr><th>ln -s filename1 filename2
</th><th>联接文件

</th><th></th></tr><tr><th>find dirname "*.c" -print
</th><th>使用匹配表达式查找文件并打印

</th><th></th></tr><tr><th>file filename
</th><th>显示文件类型

</th><th></th></tr><tr><th>head -20 filename
</th><th>显示文件的最初几行

</th><th></th></tr><tr><th>tail -20 filename
</th><th>显示文件的最后几行

</th><th></th></tr><tr><th>cut -f1,7 -d /etc/passwd 
</th><th>显示文件每行中的某些域

</th><th></th></tr><tr><th>colrm 8 20 filename
</th><th>从标准输入中删除若干列

</th><th></th></tr><tr><th>paste filename1 filename2
</th><th>横向连接文件

</th><th></th></tr><tr><th>diff filename1 filename2
</th><th>比较并显示两个文件的差异

</th><th></th></tr><tr><th>sed "s/red/green/g" filename
</th><th>非交互方式流编辑器

</th><th></th></tr><tr><th>grep "^[a-zA-Z]" filename 
</th><th>在文件中按模式查找

</th><th></th></tr><tr><th>awk '{print $1 $1}' filename 
</th><th>在文件中查找并处理模式

</th><th></th></tr><tr><th>sort -d -f -u filename
</th><th>排序或归并文件 

</th><th></th></tr><tr><th>uniq filename1 filename2
</th><th>去掉文件中的重复行

</th><th></th></tr><tr><th>comm filename1 filename2
</th><th>显示两有序文件的公共和非公共行

</th><th></th></tr><tr><th>wc filename
</th><th>统计文件的字符数、词数和行数

</th><th></th></tr><tr><th>nl filename1 > filename2
</th><th>给文件加上行号

</th><th></th></tr><tr><th>passwd
</th><th>修改用户密码 

</th><th></th></tr><tr><th>chmod ug+x filename
</th><th>改变文件或目录的权限

</th><th></th></tr><tr><th>umask 027
</th><th>定义创建文件的权限掩码

</th><th></th></tr><tr><th>chown newowner filename
</th><th>改变文件或目录的属主

</th><th></th></tr><tr><th>chgrp staff filename
</th><th>改变文件或目录的所属组

</th><th></th></tr><tr><th>make
</th><th>维护可执行程序的最新版本  

</th><th></th></tr><tr><th>touch filename
</th><th>创建文件

</th><th></th></tr><tr><th>touch -m 05202400 filename
</th><th>更新文件的访问和修改时间 

</th><th></th></tr><tr><th>ps u
</th><th>显示进程当前状态

</th><th></th></tr><tr><th>kill -9 30142
</th><th>终止进程 

</th><th></th></tr><tr><th>killall applicationname
</th><th>终止程序

</th><th></th></tr><tr><th>nice cc -c *.c
</th><th>改变待执行命令的优先级 

</th><th></th></tr><tr><th>renice +20 32768
</th><th>改变已运行进程的优先级

</th><th></th></tr><tr><th>date
</th><th>显示系统的当前日期和时间 

</th><th></th></tr><tr><th>cal month year
</th><th>显示日历

</th><th></th></tr><tr><th>time a.out
</th><th>统计程序的执行时间

</th><th></th></tr><tr><th>telnet hpc.sp.net.edu.cn
</th><th>远程登录

</th><th></th></tr><tr><th>rlogin hostname -l username
</th><th>远程登录

</th><th></th></tr><tr><th>rsh f01n03 date
</th><th>在远程主机执行指定命令

</th><th></th></tr><tr><th>ftp ftp.sp.net.edu.cn
</th><th>在本地主机与远程主机之间传输文件

</th><th></th></tr><tr><th>rcp file1 host1:file2
</th><th>在本地主机与远程主机 之间复制文件 

</th><th></th></tr><tr><th>ping hpc.sp.net.edu.cn
</th><th>给一个网络主机发送 回应请求

</th><th></th></tr><tr><th>mail
</th><th>阅读和发送电子邮件 

</th><th></th></tr><tr><th>write username pts/1
</th><th>给另一用户发送报文 

</th><th></th></tr><tr><th>mesg n
</th><th>允许或拒绝接收报文

</th><th></th></tr><tr><th>history
</th><th>列出最近执行过的 几条命令及编号

</th><th></th></tr><tr><th>alias del=rm -i
</th><th>给某个命令定义别名 

</th><th></th></tr><tr><th>unalias del
</th><th>取消对某个别名的定义 

</th><th></th></tr><tr><th>uname -a
</th><th>显示操作系统的有关信息

</th><th></th></tr><tr><th>clear
</th><th>清除屏幕或窗口内容

</th><th></th></tr><tr><th>env
</th><th>显示当前所有设置过的环境变量 

</th><th></th></tr><tr><th>who
</th><th>列出当前登录的所有用户 

</th><th></th></tr><tr><th>whoami
</th><th>显示当前正进行操作的用户名

</th><th></th></tr><tr><th>tty
</th><th>显示终端或伪终端的名称 

</th><th></th></tr><tr><th>stty -a
</th><th>显示或重置控制键定义

</th><th></th></tr><tr><th>du -k ~/Desktop
</th><th>查询磁盘使用情况

</th><th></th></tr><tr><th>df /tmp
</th><th>显示文件系统的总空间和可用空间

</th>
<th></th>
</tr>
<tr>
<th>w</th>
<th>显示当前系统活动的总信息</th>
<th></th>
</tr>
</table>

***
#Xcode
##调试命令
* 在Xcode控制台中支持输入调试命令辅助测试
* `po`，打印当前方法中的任何能够访问的OC方法或者对象属性

##模拟器及沙盒相关
* 从Xcode 6开始改了模拟器的路径位置，iOS 6的模拟器就彻底安装不上了
* 以UDID命名，如`F3BB6BA7-6BCF-42B0-8F49-498C774864DB`，区别于以前的7.1，7.0，6.1，6.0等
* 从Xcode 6开始，沙盒和Bundle分开分开，各自有各自的UDID
	* 沙盒路径
		* 在Data目录下
	* `po NSHomeDirectory()`
	`/Users/apple/Library/Developer/CoreSimulator/Devices/F3BB6BA7-6BCF-42B0-8F49-498C774864DB/data/Containers/Data/Application/CA3E18E3-6BAE-4A23-BEE5-C9856ACDB684`
	* Bundle路径
		* 在Bundle目录下
	* `po [NSBundle mainBundle]`
	`/Users/apple/Library/Developer/CoreSimulator/Devices/F3BB6BA7-6BCF-42B0-8F49-498C774864DB/data/Containers/Bundle/Application/6BC15CAE-C90E-44D6-A619-FD6A901D40D1/`

###Documents
* 只能保存由应用程序生成的相关数据，不能保存从网络下载的数据，否则会拒绝上架，因为Documents目录中的所有内容会自动备份在iCloud中

###Cache
* 缓存目录，其中内容会持久化保存，可以保存从网络下载的数据，同时希望再次使用的文件，如果在Cache中保存了文件，需要提供"清除缓存"的功能

###tmp
* 临时目录，其中的内容只是临时保存，重新启动或者存储空间吃紧 就会被清除，tmp目录文件清理不需要程序员关心

###Preferences
* 用户偏好的专属目录，平时使用`[NSUserDefault standardDefault]`去读写

##Product -> Analyze
* MRC静态分析代码工具，在发布程序时，ARC也可以使用静态代码工具

***
#ARC/MRC
##retainCount
* 引用计数，表示当前有多少个对象对该对象引用
* 苹果官方不推荐跟踪retainCount，因为一对象在真正执行中，可能会被某一个框架引用，也有可能会被框架的框架引用，造成retainCount和预期的不同

###面试题
<table>
<tr>
<th>Q</th>
<th>定义NSString *str = @"hello world"，问str的retainCount是多少</th>
</tr>
<tr>
<th>A</th>
<th>32位的系统返回最大的32位整数，64位返回最大的64位整数</th>
</tr>
</table>
* 在OC中，如果直接使用@"hello world"来定义字符串，编译后会被保存在静态区，而且如果出现相同内容的字符串，所有的字符串本质上都保存在一个位置

##ARC
* 自动引用计数
* 编译器会在会自动判断并在恰当的位置调整对象的引用计数
* ARC模式中不允许出现`retain`、`release`、`autorelease`等

##MRC
* 手动引用计数
* 需要程序员手动管理引用计数器，如果管理不当会造成内存泄漏

###开发原则
* 谁申请，谁释放，适用于面向对象开发的原则
* 如果有`alloc`、`copy`、`retain`需要做对应的`release`
* 如果有`copy`、`retain`(在ARC中就是`strong`)的属性，需要在`dealloc`中进行释放

>dealloc

	- (void)dealloc {
	   [_name release];
	   [super dealloc];
	}

###重写属性的setter方法

>setter(MRC)

	- (void)setName:(NSString *)name {
	   // 首先判断name和_name是否相等
	   if (_name != name) {
	       // 释放旧值
	       [_name release];
	       _name = name;
	       // retain新值
	       [_name retain];
	   }
	}

##_name与self.name
* 给属性设置数值的时候，使用`self.name`，可以调用系统默认的setter方法，保证retain是正确的
	* 但有*特例*
		* 第一次给属性内容设置数值的时候，苹果建议使用`_name`
		* 场景：`loadView`，`viewDidLoad`，前提是没有写懒加载方法
	* 在dealloc方法中，建议使用`[_name release];`，可以看清楚平衡关系`
		* 当然，也可以使用`self.name = nil;`这样会调用setter方法，但效率略低
* 使用`_name`的场景，通常是初始化，或者销毁

***
#Git
* 史上最牛源代码管理器！国内用的越来越多！不光适合团队开发，同样适合个人开发管理！

##文件状态
* A：Add，新增文件
* M：Modify，改动文件

##单人开发时Git的使用
* 新建项目，勾选Git
* 开发"每告一段落，提交一下"，同时填写开发改动的记录
	* 对于个人开发，可以提示自己做了哪些修改
	* 对于团队开发，可以让整个团队明白你做了什么
* 提示：写注释不要只写"修改了bug"之类没有营养的话，否则过一段时间，你都不知道自己做了什么
* 如果去公司工作，可以将公司服务器上的代码下载到本地，并且添加到本地的Git管理中

***
#SVN
* 曾被称为源代码管理王者！国内使用SVN的团队依然很多！

***
#第三方框架
##概述
* 第三方框架是由一些大牛写的程序，专门解决某一类问题，除了提供完善的功能之外，还会提供优秀的容错和兼容性的处理！

###如何判断框架的好坏
看口碑，用的人多，而且都说好，就说明是好框架，大胆的用！往死里用！

###使用第三方框架的缺点
* 作者因为某些原因，停止更新
	* 例如：ASI的网络框架，曾经被称为"HTTP访问终结者"，作者于2012年11月停止更新了，是一套MRC的框架！目前有很多老的，而且有很多用户的应用，仍然在使用ASI。
* 如果苹果系统升级，可能会短时间内，框架会出现不稳定的因素！

###如何学习第三方框架
* 学习第三方框架
	* 下载源码
	* 参照文档，测试！
	* 运行演示的代码
	* 自己创建的代码中，使用GIT管理！
	* 边阅读程序，边写注释，边写测试程序！随着我们逐步的测试，会对框架越来越了解！
* 隆重推荐一个网站[Github](http://www.github.com "Gihub")，全世界最优秀的iOS、Android等优秀的开源框架都在这个网站上能够找到源代码
* 建议：每个人都注册一个github账号，并且写在自己的简历上！
* 在Github上直接搜索第三方框架的名称，就可以找到框架首页
* 可以下载源程序
* 优秀的框架，在首页上，会有完整的使用说明文档，如果导入框架，如何使用，以及注意事项等
* Github上优秀的框架，通常是来自全世界优秀的程序员共同维护的！
* 通常面试的时候会问：你对哪些开源框架做过贡献！
* 导入第三方框架，首先编译一下，看看有没有警告错误！或者需要添加框架依赖！

##SDWebImage
###SDWebImage是如何下载并且缓存网络图片的
* 参见PPT中的沙盒缓存的流程图

###SDWebImage缓存图片的时间有多长
* SDImageCache.h中`static const NSInteger kDefaultCacheMaxCacheAge`，默认，一星期

###SDWebImage在处理图片下载时，如果出现内存警告怎么办
* 在实际开发中，如果出现内存警告，应该做一些内存清理工作
	* 取消所有的下载工作
	* 清理内存

>ReceiveMemoryWarning

	/*
	 一旦应用程序接收到内存警告，会调用此方法
	 */
	- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application {
	    // SDWebImageManager是SDWebImage下载图像的管理器
	    SDWebImageManager *mgr = [SDWebImageManager sharedManager];
	    // 取消所有下载任务
	    [mgr cancelAll];
	    
	    // 清理内存
	    [mgr.imageCache clearMemory];
	}

###SDWebImage与MD5
* 默认会把网络图片保存在沙盒的Cache目录中，图片的名称会对URL进行MD5编码
	* MD5对任何数据都可以编码，编码之后的结果都是32个字符
	* 之前沙盒缓存保存的文件名，对于网络应用，下载图片的来源通常不固定，如果单纯使用文件名，很难控制不重名，而使用md5生成的结果是包含完整路径的，从而可以避免重名问题

###SDWebImage与GIF
* 如果是网路GIF图片，可以自动播放
	* 此功能在UIImage+GIF分类来实现，使用ImageIO的框架
		* 将GIF图片下载
		* 将GIF图片中每一帧的图片依次读取出来
		* 生成一个数组，设置给UIImageView

###SDWebImage的常用方法
* `- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;`
* `- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock`
	* 参数`option`通常使用以下两个选项即可
		* `SDWebImageLowPriority`，低优先级，滚动是暂停下载
		* `SDWebImageRetryFailed`，下载失败后自动重试
	* `SDWebImageOptions op = SDWebImageLowPriority | SDWebImageRetryFailed;`

***
#iOS系统架构层次
<table>
<tr>
<th>Your Application</th>
</tr>
<tr>
<th>
	<table>
	<tr>
	<th>UIKit</th>
	</tr>
	</table>
Cocoa Touch
</th>
</tr>
<tr>
<th>Media Services</th>
</tr>
<tr>
<th>Core Services
	<table>
	<tr>
	<th>Foundation</th>
	</tr>
	</table>
</th>
</tr>
<tr>
<th>Core OS</th>
</tr>
</table>

***
#iOS系统框架表
<table>
<tr>
<th>框架名称</th>
<th>功能</th>
</tr>
<tr>
<th>Foundation</th>
<th>提供OC的基础(像NSObject)、基本数据类型等</th>
</tr>
<tr>
<th>UIKit</th>
<th>创建和管理应用程序的用户界面</th>
</tr>
<tr>
<th>QuartzCore</th>
<th>提供动画特效以及通过硬件进行渲染的能力</th>
</tr>
<tr>
<th>CoreGraphics</th>
<th>提供2D绘制的基于C的API</th>
</tr>
<tr>
<th>SystemConfiguration</th>
<th>检测当前网络是否可用和硬件设备状态</th>
</tr>
<tr>
<th>AVFoundation</th>
<th>提供音频录制和回放的底层API，同时负责管理音频硬件</th>
</tr>
<tr>
<th>CFNetwork</th>
<th>访问和配置网络，像HTTP、FTP和Bonjour Services</th>
</tr>
<tr>
<th>CoreFoundation</th>
<th>提供抽象的常用数据类型，如Unicode strings、XML、URL等</th>
</tr>
<tr>
<th>CoreLocation</th>
<th>使用GPS和WIFI获取位置信息</th>
</tr>
<tr>
<th>GameKit</th>
<th>为游戏提供网络功能：点对点互联和游戏中的语音交流</th>
</tr>
<tr>
<th>AddressBook</th>
<th>提供访问用户联系人信息的功能</th>
</tr>
<tr>
<th>AddressBookUI</th>
<th>提供一个用户界面，显示存储在地址簿中的联系人信息</th>
</tr>
<tr>
<th>AudioToolBox</th>
<th>提供音频录制和回放的底层API，同时负责管理音频硬件</th>
</tr>
<tr>
<th>AudioUnit</th>
<th>提供一个接口，让应用程序可以对音频进行处理</th>
</tr>
<tr>
<th>MapKit</th>
<th>为应用程序提供内嵌地图的接口</th>
</tr>
<tr>
<th>MediaPlayer</th>
<th>提供播放视频和音频的功能</th>
</tr>
<tr>
<th>MessageUI</th>
<th>提供视图控制接口用以处理E-mail和短信</th>
</tr>
<tr>
<th>OpenGLES</th>
<th>提供动画特效以及通过硬件进行渲染的能力</th>
</tr>
<tr>
<th>StoreKit</th>
<th>为应用程序提供在程序运行中消费的支持</th>
</tr>
</table>

***===
#UIApplication

***
#UIWindow

***
#RunLoop运行循环
##作用与特性
* 保证程序不退出
* 监听*所有*事件，手势触摸、时钟触发、网络加载数据完成
* 没有事件时回休眠(省电)，一旦监听到事件会会响应
* 程序启动后会创建RunLoop，每一个线程都有一个RunLoop，但只有主线程的RunLoop会启动

##例子
* 按钮点击事件是如何响应的？
	* `addTarget`只是注册(给RunLoop)点击按钮后执行控制器的`click`方法
<table>
<tr>
<th>Application</th>
<th>⬇️</th>
</tr>
<tr>
<th>runloop</th>
<th>⬇️</th>
</tr>
<tr>
<th>Window</th>
<th>⬇️</th>
</tr>
<tr>
<th>ViewController</th>
<th>⬇️</th>
</tr>
<tr>
<th>View</th>
<th>⬇️</th>
</tr>
<tr>
<th>Button</th>
<th>⬇️</th>
</tr>
</table>

***
#autoreleasepool自动释放池
##问答
* 自动释放池的作用是什么？
	* 延迟释放
* 那些对象会延迟释放？
	* 所有用类方法实例化的对象都是延迟释放的
* 对象何时被销毁？
	* 所有延迟释放的对象在超出作用域之后会被添加到*最新创建的*自动释放池中，但是不会被立即销毁，当自动释放池被销毁时，会向池中所有对象发送release消息，释放所有延迟释放的对象
* 自动释放池何时被销毁？

>示意图

<table>
<tr>
<th>iPhone Application Launches</th>
<th>></th>
<th>iPhone Touch Event</th>
<th rowspan="1" colspan="6">></th>
<th>Cocoa Touch Creates Event</th>
<th>></th>
<th>Event Object</th>
</tr>

<tr>
<th rowspan="6" colspan="2"></th>
<th rowspan="6" colspan="1">⬆️</th>
<th rowspan="1" colspan="6"></th>
<th>⬇️</th>
<th rowspan="4" colspan="1"></th>
<th rowspan="4" colspan="1">⬇️</th>
</tr>

<tr>
<th rowspan="4" colspan="1">⬆️</th>
<th>></th>
<th rowspan="1" colspan="3">Autorelease Pool</th>
<th><</th>
<th rowspan="2" colspan="1">Cocoa Touch Creates Autorelease Pool</th>
</tr>

<tr>
<th rowspan="3" colspan="1"></th>
<th rowspan="1" colspan="4"></th>
</tr>

<tr>
<th rowspan="1" colspan="3">Application Object(s)</th>
<th>⬅️</th>
<th>⬇️</th>
</tr>

<tr>
<th rowspan="1" colspan="4"></th>
<th>Application Handles Event</th>
<th rowspan="1" colspan="2"><</th>
</tr>

<tr>
<th rowspan="1" colspan="6">Cocoa Touch Darins Autorelease Pool</th>
<th><</th>
<th rowspan="1" colspan="2"></th>
</tr>
</table>

* 自动释放池在ARC中工作吗？
	* 工作，编译器在编译时会根据代码添加`retain`、`release`、`autorelease`

##面试题
###题目
* 以下代码是否有问题，如果有该如何修正？

>题目

	int largeNo = 2 * 1024 * 1024;
	for (int i = 0;i < largeNo;i++){
		NSString *str = [NSString stringWithFormat:@"Hello"];
		str = [str uppercaseString];
		str = [str stringByAppendingString:@" World"];
	}

###答案
* 每一次都会实例化新的str，超出作用域之后会被添加到自动释放池中，如果循环次数很多，会在一次循环之后把自动释放池耗尽

>解决

	int largeNo = 2 * 1024 * 1024;
	@autoreleasepool { // 放在外面，保证循环之后释放循环中的自动释放对象
		for (int i = 0;i < largeNo;i++){
			//@autoreleasepool { 
			// 放在内部，每一次循环之后，都倾倒一次自动释放池，内存管理时最好的，但性能不好
				NSString *str = [NSString stringWithFormat:@"Hello"];
				str = [str uppercaseString];
				str = [str stringByAppendingString:@" World"];
			//}
		}
	}

##NSThread添坑
* 找坑
	* NSThread新建的线程不会创建自动释放池，一旦有自动释放的对象就无法处理
* 添坑
	* 在NSThread包括NSObject的多线程方法中，需要自己添加自动释放池

***
#StoryBoard

***
#Xib
* 从文件中读取需要的组件
	* `NSArray *bundelArr = [[NSBundle mainBundle]loadNibNamed:@"myCell" owner:nil options:nil];
 cell = bundelArr[0]`
	* nib其实是一个xib,里面是数组保存了各个组件。

* 注册nib文件，并且给表格注册可重用的nib
	* 这样做的好处是能简化cell优化的过程，这样在初始化cell的时候就不用判断是否为nil

>e.g.

	- (void)viewDidLoad {
		[super viewDidLoad];
		UINib *nib = [UINib nibWithNibName:@"myCell" bundle:nil];
		[self.tableView registerNib:nib forCellReuseIdentifier:@"myCell"];
	}

* 在对按钮进行设置target时候，注意判断是否一直在给button加监听时间

>e.g.

    UIButton *button = (UIButton *)[cell viewWithTag:103];
    // 在为按钮添加监听方法前，需要判断按钮是否已经被监听
    if ([button allTargets].count == 0) {
		[button addTarget:self action:@selector(buy:forEvent:) forControlEvents:UIControlEventTouchUpInside];
		NSLog(@"监听数量：%d", button.allTargets.count);
	}

***
#UIView与UIViewController
* 视图与视图控制器

##UIView与UIViewController
###UIView
* 负责界面的显示

###UIViewController
* 负责界面元素及内容的控制和调度

* 每个UIViewController默认都有一个UIView属性，每一个UIView都是一个容器，容纳其他UIView

##程序启动过程简述
<table>
<tr>
<th>读取MainStoryboard.storyboard</th>
</tr>
<tr>
<th>创建ViewController</th>
</tr>
<tr>
<th>根据视图storyboard文件中的描述创建ViewController的UIView对象</th>
</tr>
<tr>
<th>将UIView对象显示到手机屏幕上</th>
</tr>
<tr>
<th>监听并响应用户交互</th>
</tr>
</table>

##loadView方法
* 苹果为了纯代码创建视图层次结构准备的方法，一旦实现了次方法，Storyboard和Xib都将无效
* 在此方法中，应该做与Storyboard等价的工作，用户看到的所有控件的初始化全部在此方法中完成
* 注意，不能[super loadView]
* 注意，在self.view实例化之前，不能使用self.view，会死循环

##viewDidLoad方法

* 此方法是视图加载完成之后执行的方法，通常loadView执行完成后会调用此方法
* 如果有loadView，不要在此方法中，创建控件
* 如果没有loadView，可以创建一些简单控件
* 可以做一些数据初始化工作，数据初始化也可以通过懒加载的方式实现

* 在加载完storyboard.storyboard后自动执行

>viewDidLoad

	- (void)viewDidLoad{ 
	[super viewDidLoad]; // 必须继承
	}

##UIView的常用属性
* superview
	* 获得父视图 

`@property(nonatomic, readonly) UIView  *superview;`

* subviews
	* 获得所有子视图

`@property(nonatomic, readonly, copy) NSArray *subviews;`

##frame/bounds/center
###frame	位置与尺寸属性
* 控件所在矩形框的位置和尺寸
* 坐标系原点为父视图的左上角，向右横轴递增，向下纵轴值递增

###bounds尺寸属性
* 控件所在矩形框的位置和尺寸
* bounds的坐标系原点为自身的左上角，向右横轴递增，向下纵轴值递增

###center中心点属性
* 控件中点的位置，通过center属性设置视图位置更加方便
* center的坐标系原点为父视图的左上角，向右横轴递增，向下纵轴值递增

###使用注意
* 用frame和center可以修改UIView的位置
* 用frame和bounds可以修改UIView的尺寸
* 通常，修改自身位置大小时使用frame，而子视图（控件）在设置位置时，会相对父视图的bounds进行设置

###通过frame.origin.x和frame.origin.y进行位置操作
>e.g.

    CGRect rect=_bt.frame;
    rect.origin.y +=10;
    [_bt setFrame:rect];

##tag标记属性
* 控件的ID（标记），父控件可以通过tag来找到或区分子控件
* `@property(nonatomic)  NSInteger tag;`
* 通过tag来实现多个button点击事件指向一个函数，但是注意函数传入的参数要是`(UIButton *)sender`

##transform形变属性
* 控件的形变属性（可以设置旋转角度、比例缩放、平移等属性）
* UIView一次只能应用一个形变属性
* 设置`transfrom`会改变UIView的frame属性，但不会改变bounds属性
* `CGAffineTransformMakeScale`相对UIView的初始状态进行形变
* `CGAffineTransformScale`相对UIView的当前状态进行形变

###Rotate旋转:
* `CGAffineTransformMakeRotation(CGFloat sx, CGFloat sy)`
* `CGAffineTransformRotate(CGAffineTransform t, CGFloat sx, CGFloat sy)`

>e.g.

	CGAffineTransform  transfromMake= CGAffineTransformMakeRotation(M_PI_4);
	CGAffineTransform transfrom= CGAffineTransformRotate(_subView.transform, M_PI_4);
	[_view setTransform:transform];
	//使用TransformMakexxx方法是相对视图初始位置的形变,所以只能旋转一次
	//择角度的参数是弧度值,弧度值是浮点数,180角度对应的弧度是PI，90 = PI/2;

###Scale缩放
* `CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)`
* `CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)`

###Translation平移
* `CGAffineTransformTranslation(CGAffineTransform t, CGFloat tx,CGFloat ty)`
* `CGAffineTransformMakeTranslation(CGFloat tx,CGFloat ty)`

##Animations动画效果
###设置动画效果:
	[UIView beginAnimations:nil context:nil]; // 开启动画
	[UIView setAnimationDuration:.3]; // 设置动画持续时间
	[UIView commitAnimations]; // 结束动画

###UIView封装的块动画方法
* `[UIView animateWithDuration: animations:^{}]`
* `[UIView animateWithDuration: animations:^{} completion:^{}]`
* `[UIView animateWithDuration: delay: options: animations:^{} completion:^{}]`
* 这些方法都可以实现动画嵌套

> e.g.

	[UIView animateWithDuration:2.0f animations:^{
	        [_subView setTransform:transform]; // transform是你设置的动画效果
	    } completion:^(BOOL finished) {
	        [UIView animateWithDuration:1.0f animations:^{
	        [_subView setBackgroundColor:[UIColor redColor]];// 设置视图背景颜色
	        [_subView setAlpha:0.1f];// 设置视图透明度
	       }]; 
	    }];

<!--(8)通过改变button的Tag来操作按钮的状态
例子:
- (IBAction)actionMethod:(id)sender {
    CGAffineTransform tranfrom;
    if ([_subView tag]==0) { 
        tranfrom = CGAffineTransformScale(_subView.transform, 1.2, 1.5);
        [_subView setTag:1];
    }else{
        tranfrom = CGAffineTransformScale(_subView.transform, 1.0/1.2, 1.0/1.5);
        [_subView setTag:0];
    }
    [_subView setTransform:tranfrom];
}-->

***
#UITextField
* 文本输入框

##打开键盘
* `[textField becomeFirstResponder]`

##关闭键盘
* `[self.view endEditing:YES]`
* `[textField resignFirstResponder]`

##回车事件
* 遵守协议`<TextFieldDelegate>`
* 实现`textFieldShouldReturn`方法

>e.g.

	-(BOOL)textFieldShouldReturn:(UITextField *)textField{
		// 处理回车后的事件
	}
 
##清空按钮
* 通常选择Appears While Editing，即仅编辑时出现

##安全输入
* `[textField setSecureTextEntry:YES]`

##边框风格
* 用代码创建文本框时，默认是没有边框的，需要自行制定一下
* `[textFiled setBorderStyle:UITextBorderStyleLine]`

##文字对齐
* `[textField setContentVerticalAlignment:UIControlContentVerticalAlignmentCenter]`

***
#UIButton
* 按钮

##按钮类型
* `UIButtonTypeCustom`按钮的内容需要自定义
* `UIButtonTypeRoundedRect`圆角矩形按钮
* `UIButtonTypeDetailDisclosure`显示明细按钮
* `UIButtonTypeInfoLight`亮色信息按钮，用于深色背景
* `UIButtonTypeInfoDark`深色信息按钮，用户浅色背景
* `UIButtonTypeContactAdd`添加按钮

##按钮状态
* `UIControlStateNormal`正常状态
* `UIControlStateHighlighted`高亮状态
* `UIControlStateSelected`选中状态
* `UIControlStateDisable`不可用状态
* `[button setEnabled:BOOL]`

##按钮文字
* `[button setTitle: forState:]`
* `[button titleLabel] text]`

##文字颜色
* `[button setTitleColor: forState:]`
    
##背景颜色
* 要设置按钮的背景颜色，需要使用自定义类型的按钮
* `[button setBackgroundColor:]`

##背景图片
* `[button setBackgroundImage: forState:]`

##按钮图片
* `[button setImage: forState:]`

##监听事件
* `[button addTarget:self action:@selector() forControlEvents:UIControlEventTouchUpInside]`

***
#UISWitch
* 开关

##设置状态
* `[switch setOn:YES]`

##判断状态
* `BOOL state = [switch isOn]`

##事件监听
* 监听UISwitch的状态改变，应该用Value Changed事件（参照UISlider的使用）

***
#UIStepper
* 基本设置与滑块控件类似

##与UISWitch的区别：
* 每按一次减号，value就会自动减去一定的数值(数值大小由stepValue决定)
* 每按一次加号，value就会自动增加一定的数值(数值大小由stepValue决定)

##事件监听
* 监听UISwitch的状态改变，应该用Value Changed事件（参照UISlider的使用）

***
#UISlider
* 滑动条

##设置最大值
* `[slider setMaximumValue:15]`

##设置最小值
* `[slider setMinimumValue:0]`

##设置当前值
* `[slider setValue:5]`

##设置滑动条图片

##设置滑块图片

##事件监听
* 监听UISlider的进度值改变，应该用Value Changed事件
* `[slider addTarget:self action:@selector() forControlEvents:UIControlEventValueChanged]`
* 当UISlider的进度值发生改变时，会自动调用self的sliderChange:方法，并且将UISlider作为第一个参数传入
	* `- (void) sliderChange:(UISlider *)slider{ ... }`

##注意
* 在拉动滑块的时候，从1-2中有很多数，它会不停的去设置图片，影响效率，这边我要自己定义一个变量来记录

***
#UILabel
##标签文字
* `[label setText:]`

##文字颜色
* `[label setTextColor:]`
    
##背景颜色
* `[label setBackgroundColor:]`

***
#UISegmentControl
* 选项卡控件
* 同一时刻只能选中一个标签

##基本设置
* `UISegmentedControl *segmentControl = [[UISegmentedControl alloc] initWithItems:@[@"2列", @"3列", @"4列"]]`

##获得当前被选中的标签位置
* `segmentControl.selectedSegmentIndex`

##事件监听
* 监听UISegmentControl的状态改变，应该用Value Changed事件（参照UISlider的使用）

***
#UIAlertView
* 提示框
* 需要遵守协议`<UIAlertViewDelegate>`

##初始化
* `- (id)initWithTitle:(NSString *)title message:(NSString *)message delegate:(id /*<UIAlertViewDelegate>*/)delegate cancelButtonTitle:(NSString*)cancelButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION`

##样式
* `UIAlertViewStyleDefault = 0`
* `UIAlertViewStyleSecureTextInput`
* `UIAlertViewStylePlainTextInput`
* `UIAlertViewStyleLoginAndPasswordInput`

##设置样式
* `[alert setAlertViewStyle:UIAlertViewStylePlainTextInput]`

##传递参数到alert中的 textField
* `[[alert textFieldAtIndex:0] setText:]`

##按钮点击事件
* 代理方法
* `- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex`

===========================
#UIActionSheet


***
#UIImageView
##设置图像
* `[imageView setImage:]`

##显示模式
* `imageView.contentMode  =  UIViewContentModeScaleAspectFit`

##序列帧动画
* 即让一系列的图片在特定的时间内按顺序显示

###属性
* `animationImages`要显示的一组图片序列
* `animationDuration`完整地显示所有图片所需的时间
* `animationRepeatCount`动画的执行次数（默认为0，代表无限循环）

###方法
* `- (void)startAnimating`开始动画
* `- (void)stopAnimating`停止动画
* `- (BOOL)isAnimating`是否正在运行动画

>e.g.

	- (void)setAnimation:(NSInteger)count andButton:(UIImageView *)imageView{
	    NSMutableArray *imagesList = [NSMutableArray array];
	    for (NSInteger i = 1; i < count; i++) {
	        NSString *fileName = [NSString stringWithFormat:@"%d.png", i]; // 生成图像文件名
	        UIImage *image = [UIImage imageNamed:fileName];
	        [imagesList addObject:image];// 把图像添加到数组
	    }
	    [imageView setAnimationImages:imagesList];
	    [imageView setAnimationDuration:1.0];//设置动画播放的时长
	    [imageView setAnimationRepeatCount:1];//设置动画播放次数
	    [imageView startAnimating]; //开始动画
	}

##注意
* 使用`[UIImage imageNamed:]`加载的UIImage对象，会被保存在系统缓存中并且释放的非常缓慢，使用此方法适合于加载较小的图像或者频繁使用的图像；
* 使用`[UIImage imageWithContentsOfFile:[[NSBundle mainBundle]pathForResource: ofType:]]`加载的UIImage对象一旦使用完毕就会被释放，适合加载较大的图像，或者使用不频繁的图像

***
#UITableView与UITableViewController

##UITableView
* 列表视图
* 需要数据源和代理
	* 凡是遵守`<UITableViewDataSource>`协议的OC对象，都可以是UITableView的数据源dateSource
	* 凡是遵守了`<UITableViewDelegate>`协议的OC对象，都可以是UITableView的代理对象

###内置样式
* `UITableViewStylePlain`
* `UITableViewStyleGrouped`

###Separator属性
* No Selection
* Single Selection
* Multiple Selection
	
###UITableViewDataSource协议
* 遵守`<UITableViewDataSource>`协议
* `@property (nonatomic, weak) id<UITabelViewDateSource> dateSource;`
* 实现方法

####分组数量
* `- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {}`

####每组行数
* `- (NSInteger)tableView:numberOfRowsInSection:(UITableView *)tableView {}`

####每行数据(cell)
* `- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath)indexPath {}`

####每组顶部视图
* `-(NSString *)tableView: titleForHeaderInSection:`

####每组底部视图
* `-(NSString *)tableView: titleForFooterInSection:`

###UITableViewDelegate协议
* 遵守`<UITableViewDelegate>`协议
* `@property (nonatomic, weak) id<UITableViewDelegate> delegate;`
* 实现方法

####行被选中
* `- (void)tableView:didSelectRowAtIndexPath:`

####每行高度
* `- (CGFloat)tableView:heightForRowAtIndexPath:`

####侧边索引
* `- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView;`

###contentView
* contentView下默认有3个子视图
	* imageView
	* textLabel
	* detailTextLabel
* UITableViewCell的UITableViewCellStyle，用于决定使用contentView的哪些子视图，以及这些子视图在contentView中的位置

###UITableViewCell
* UITableView的每一行都是一个UITableViewCell，通过dataSource的`tableView:cellForRowAtIndexPath:`方法来初始化每一行
* UITableViewCell是UIView的子类，内部有个默认的子视图contentView
* contentView是UITableViewCell所显示内容的父视图，并负责显示一些辅助指示视图
* 辅助指示视图的作用是显示一个表示动作的图标，可以通过设置UITableViewCell的`accessoryType`来显示
	* `UITableViewCellAccessoryDisclosureIndicator`
	* `UITableViewCellAccessoryDetailDisclosureButton`
	* `UITableViewCellAccessoryCheckmark`
	* `UITableViewCellAccessoryNone`(默认)

###刷新数据
####刷新所有数据
* `[tableView reloadData]`

####刷新部分行数据
* `- (void)reloadRowsAtIndexPaths:(NSArray*)indexPaths withRowAnimation:(UITableViewRowAnimation)animation {}`

<!--点击选中表格row的传递
//条目点击方法
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
}

思路一:通过组件的tag来传递 row

思路二: indexPathForSelectedRow来获得被选中条目的row的
NSIndexPath *indexPath =[_uiTableView indexPathForSelectedRow]; //获取被点击条目的NSIndexPath
NSInteger row = [indexPath row];

NSIndexPath *indexPath = [_uiTableView indexPathForRowAtPoint];//通过手指触摸获得点击条目的
UITableViewCell *cell = [_uiTableView cellForRowAtIndexPath:indexPath]; //获取被点击的条目cell对象


(8)优化UITableView
iOS设备的内存有限，如果用UITableView显示成千上万条数据，就需要成千上万个UITableViewCell对象的话，那将会耗尽iOS设备的内存。要解决该问题，需要重用UITableViewCell对象
重用原理：当滚动列表时，部分UITableViewCell会移出窗口，UITableView会将窗口外的UITableViewCell放入一个对象池中，等待重用。当UITableView要求dataSource返回UITableViewCell时，dataSource会先查看这个对象池，如果池中有未使用的UITableViewCell，dataSource会用新的数据配置这个UITableViewCell，然后返回给UITableView，重新显示到窗口中，从而避免创建新对象

*(原理图)*

-----------Cell是一样的表格:
static NSString * cellIndetifier = @"MyCell";//加static保证标示符永远只有一个.
UITableViewCell *cell= [_uiTableView dequeueReusableCellWithIdentifier:cellIndetifier];
 if (cell == nil) {
        cell  = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:cellIndetifier];
    }

   ------------Cell 不一样的表格:
 -->

###UITableView编辑模式
* UITableView属有个editing性，当设置为YES时，可以进入编辑模式
* 在编辑模式下，可以管理表格中的行，比如改变行的排列顺序、增加行、删除行，但不能修改行的内容

>editing

	@property(nonatomic,getter=isEditing) BOOL editing;
	- (void)setEditing:(BOOL)editing animated:(BOOL)animated;

* 开启表格的编辑模式
* 实现UITableViewDataSource的方法,判断表格是否删除了内容：
	* `- (void)tableView:commitEditingStyle:forRowAtIndexPath:`
* 实现UITableViewDelegate的方法,返回表格的编辑样式
	* `- (UITableViewCellEditingStyle)tableView: editingStyleForRowAtIndexPath:`
		* UITableViewCellEditingStyle
			* `UITableViewCellEditingStyleDelete`删除style 
			* `UITableViewCellEditingStyleInsert`插入style

>editing

	- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath{
	    return _uiTableView.tag; //用tag来记录按钮点击后的style
	}
	
	- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath{
	    if (editingStyle == UITableViewCellEditingStyleDelete) {
	        //删除.刷新
	        [_dataArr removeObjectAtIndex:indexPath.row];
	        [_uiTableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationRight];
	    }else{
	        //增加.刷新
	        [_dataArr insertObject:@"新增数据" atIndex:(indexPath.row + 1)];
	        NSIndexPath *newPath = [NSIndexPath indexPathForRow:indexPath.row + 1 inSection:0];
	        [_uiTableView insertRowsAtIndexPaths:@[newPath] withRowAnimation:UITableViewRowAnimationTop];
	    }
	}

>cell移动

	- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{
    	NSString *str=_dataArr[sourceIndexPath.row];
    	[_dataArr removeObjectAtIndex:sourceIndexPath.row];
    	[_dataArr insertObject:str atIndex:destinationIndexPath.row];
	}

>cell增加

	- (IBAction)btClick1:(id)sender {
    	[_uiTableView setTag:UITableViewCellEditingStyleDelete];
    	BOOL isEditing=[_uiTableView isEditing];
    	[_uiTableView setEditing:!isEditing animated:YES];
	}

>cell删除

	- (IBAction)btClick2:(id)sender {
    	[_uiTableView setTag:UITableViewCellEditingStyleInsert];
    	BOOL isEditing=[_uiTableView isEditing];
    	[_uiTableView setEditing:!isEditing animated:YES];
	}

###总结UITableView刷新数据的四种方法
* 新增表格数据
	* [tableView insertRowsAtIndexPaths:@[path] withRowAnimation:UITableViewRowAnimationTop];
* 删除表格数据
	* [tableView deleteRowsAtIndexPaths:@[path] withRowAnimation:UITableViewRowAnimationRight];
* 局部刷新指定的行
	* [tableView reloadRowsAtIndexPaths:@[path] withRowAnimation:UITableViewRowAnimationMiddle];
* 刷新全部表格数据，如果能够准确确定被修改的数据行，就不要用此方法
	* [tableView reloadData];

###其他
* 通过tag来获取cell中的组件，注意tag不能从0开始
* 因为`tableViewCell`的`contentView`默认包含了`textLabel`、`detailLabel`、`imageView`，所以定义组件的名称的时候也不要重名
* `UILabel *label = (UILabel *)[cell viewWithTag:100];`


***
#UINavigationViewController
* 要使用Push连线推出新的视图控制器必须要有NavigationController
* 连线方法
	* `- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender;`
* 触摸事件

>touchEvent

	- (void)click:(id)sender forEvent:(UIEvent *)event{
		NSSet *set=[event allTouches];
	    UITouch *touch=[set anyObject];
	    CGPoint point=[touch locationInView:self.tableView];
	    NSIndexPath *indexPath=[self.tableView indexPathForRowAtPoint:point];
	    NSLog(@"%@",indexPath);
	}

***

***

***

***

***

***
#自动布局
* 建议
	* 多用Storyboard练习自动布局
* 技巧
	* 在界面上摆放好控件的位置
	* 使用自动布局添加"约束"（蓝色的线）

##Size Classes
* Compact：压缩的
* Reguler：常规的

##约束
* 注意
	* 一旦设置了约束，可以通过修改约束数值，调整控件位置，不要再调整frame

##参考
* 任何一个控件都可以参照另外控件准确定义出位置`frame(x, y, width, height)`
* 注意
	* 使用了自动布局，就“不要”再用代码改frame，因为已经将所有的布局交给了自动布局系统！

##其他
* pin是指定大小和位置
* algin可以指定对齐方式
* 红色的提示：表示缺少约束
* 黄色的提示：控件的实际位置与约束的数值不相符

***
#事件处理与响应者链条

***
#UI面试题
##一个iOS 6的程序在iOS 7的设备中直接运行，通常会出现什么问题？
* 最明显的区别是20个点
	* 在iOS 6中，self.view的位置从状态栏下方开始计算
	* 在iOS 7中，self.view的大小就是整个屏幕的大小
	*如果是用纯代码创建的项目，在iOS 7中会偏差20个点
* 穿透
	* 在iOS 6中，UITableView的起始位置是从NavigationBar下方开始计算的，不能实现穿透效果
	* 在iOS 7中，UITableView的起始位置是屏幕顶端，可以实现穿透效果

***
#block
##定义
###inlineBlock
	return_value ^(block_name)(arg_list) = return_value ^(arg_list){
		code_block;
	}

###typedefBlock
* block是一种数据类型，可以定义类型，当作返回值

>typedefBlock.m

	#import <Foundation/Foundation.h>
	typedef void^(myBlock)();
	myBlock myDemo(){
		myBlock mb = ^{
			NSLog(@"test");
		}
		return mb;
	}
	int main(){
		myBlock mb = myDemo();
		mb();
		return 0;
	}

##循环引用问题
* block在定义时会默认对外部变量做一次`copy`(强引用)
* 在Obj-C中定义指针变量默认都是`strong`类型，可以使用`__weak`修饰改为弱引用
* 如果block中出现`self`时要加以注意，可能会出现循环引用(并非绝对)
* 利用`dealloc`方法可以协助检测循环引用

##调用
* `block_name(arg_list)`

##自定义视图传值:block与代理
###正向传值
###反向传值
###实现
* block
	* 调用方
		* 准备块代码
	* 被调用方
		* 定义代码块属性
		* 需要时执行
* 代理
	* 代理
		* 遵守协议
		* 设置代理
		* 实现方法
	* 委托
		* 定义协议
		* 定义代理属性
		* 需要时调用代理方法

###block与代理的选择
* block与代理在一些场合时可以互换的	
	* block
		* block适合比较小巧的回调，通常1~3回调方法比较合适
		* 如果回调的方法很多时使用block会显得很臃肿，例如UITableView
	* 代理
		* 使用代理可以制定协议方法是否必须实现

##block数组排序/遍历

###compare方法
* 可以比较两个对象（NSNumber, NSString, NSDate....）

>compare

	- (NSComparisonResult)compare:(NSNumber *)otherNumber;

###数组排序
>sortedArrayUsingComparator

	- (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);
	typedef NS_ENUM(NSInteger, NSComparisonResult) {NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending};
	/*
    NSOrderedAscending = -1L, 升序
    NSOrderedSame,            相同
    NSOrderedDescending       降序
    */
	#if NS_BLOCKS_AVAILABLE
	typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);
	#endif

###数组遍历
* 所有的参数都已经准备到位，可以直接使用
* 效率比传统方式快(对比`for ( in ){}`)

>enumerate

	- (void)enumerateObjectsUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);

###示例代码
>array_block.m

	#import <Foundation/Foundation.h>
	int main(){
		NSArray* array = @[ @5, @4, @2, @1, @3 ];
		// 数组排序
        NSArray* result = [array sortedArrayUsingComparator:^NSComparisonResult(NSNumber* num1, NSNumber* num2) {
        	// 升序
        	return [num1 compare:num2];
	    }];
        NSLog(@"%@", result);
    }
    
	// 数组遍历
	void enumerate(NSArray *array){
	    [array enumerateObjectsUsingBlock:^(NSNumber* num, NSUInteger idx, BOOL* stop) {
	        NSLog(@"%@", num);
	        if (idx == 3) { // 遍历到第三个时结束
	            *stop = YES;
	        }
	    }];
	}

##block常见面试题
###block-copy
>block_copy_release.m

	#import <Foundation/Foundation.h>
	typedef void^(myBlock)();
	myBlock myDemo(){
		int i = 10;
		myBlock mb = ^{
			NSLog(@"i = %d",i);
		}
		//错误解决办法:return [mb copy];
		return Block_copy(mb);
	}
	int main(){
		myBlock mb = myDemo();
		mb();
		Block_release(mb);
		return 0;
	}

###重构
* 新建方法
* 将代码复制到新方法
* 调整参数

>

	#import <Foundation/Foundation.h>
	void myDay(void (^myWork)()) // 和 inlineBock 的左边一模一样
	{
	    NSLog(@"起床");
	    NSLog(@"出门");
	    // 执行block参数，在需要的时候执行
	    myWork();
	    NSLog(@"下班回家");
	    NSLog(@"洗洗睡了");
	}
	
	void day1()
	{
	    // 准备代码，格式和inlineBlock右边一模一样
	    myDay(^{
	        NSLog(@"新人报道");
	    });
	}
	
	void day2()
	{
	    myDay(^{
	        NSLog(@"看公司代码");
	    });
	}
	
	int main(){
		day1();
		day2();
		return 0;
	}

***
#copy与mutableCopy
##普通对象的拷贝
* copy的目的是在修改原始版本和副本的时候，彼此各不干扰
* `copy`拷贝为不可变对象
* `mutableCopy`拷贝为可变对象
<table>
<tr>
<th>源对象</th>
<th>方式</th>
<th>操作</th>
<th>类型</th>
</tr>
<tr>
<th rowspan="2" colspan="1">不可变</th>
<th>copy</th>
<th>引用计数+1</th>
<th>浅拷贝，指针拷贝</th>
</tr>
<tr>
<th>mutableCopy</th>
<th rowspan="3" colspan="1">新建副本</th>
<th rowspan="3" colspan="1">深拷贝，对象拷贝</th>
</tr>
<tr>
<th rowspan="2" colspan="1">可变</th>
<th>copy</th>
</tr>
<tr>
<th>mutableCopy</th>
</tr>
</table>

* `@property (nonatomic, copy) NSString *str;`
* 给copy属性设置数值时，默认会做一次copy操作，拷贝出不可变的版本
	* 目标值是可变的，会建立一个不可变的副本
	* 目标值是不可变的，只是引用计数＋1，于strong等效
* 在OC中，对象真正的类型是实例化对象的时候，所采用的类型决定的

##自定义对象的拷贝
* 在很多第三方框架或者大型的应用程序中，会给自定义对象提供copy方法，方便快速建立类似的副本
* 自定义对象要支持copy方法，需要做两件事
	* 遵守`<NSCopying>`协议
	* 实现`copyWithZone`方法
	
###Zone
* 空间，在非常底层才会使用，给对象分配内存空间的时候，是在堆中的
* Zone是如果程序员希望堆中的分配空间相对连续，或者集中才会使用
* 目的是为了减少对中的内存碎片，一般程序开发不需要，也完全没有必要关心
* copy方法，最终会调用到copyWithZone方法

***
#设计模式
* 经过无数程序员共同努力，在开发中经常碰到的问题，进行归纳汇总，抽取出来的模式，被称为设计模式，每一个模式通常专门解决一类问题
* 目前共有23种设计模式(来源：四人帮 Bang of Four 写的"设计模式")
* 模式来源于开发，不要为了模式而模式

##MVC
* 用于解决数据、显示、控制分离，让代码解耦！
* `Model`模型
* `View`视图
* `Controller`控制器	

###Model模型
####.plist文件
#####概念
* 记录数据的文件，又称属性列表，是一种XML格式的文件
* 可以保存NSString、NSNumber、NSDate和NSData四种数据类型的数据
* 可以与NSArray和NSDictionary组合使用建立数组或者数据字典

#####读取
* 从NSBundle加载Plist文件的方式
* Plist文件中的数组和数据字典使用的方式
* 在.m中的接口定义可以用于定义私有成员变量、属性或者方法

#####数组示例
	NSBundle *bundle = [NSBundle mainBundle];
	NSString *path = [bundle pathForResource:@"images" ofType:@"plist"];
	NSMutableArray *arr= [NSMutableArray arrayWithContentsOfFile:path];
	/*
	     (xx,xx,xx,)    ->数组格式
	     {kk="",mm=""}   ->字典格式
	     ({icon="";title=""},{},{}) ->返回的arr数据,下面是读取其中的数据
	*/
	 - (void)resetPhotoInfoWithIndex:(NSInteger)index{
	    NSDictionary *dict = _imageData[index];
	    NSString *imageFile = dict[@"icon"];
	    NSString *text = dict[@"title"];
	}

#####字典示例
	NSBundle *bundle=[NSBundle mainBundle];
	 _cities = [NSMutableDictionary dictionaryWithContentsOfFile:[bundle pathForResource:@"cities" ofType:@"plist"]];

#####在建立静态表格的时候设置plist的文档结构
>e.g.

	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
	<plist version="1.0">
	<array>
		<array>
			<dict>
				<key>name</key>
				<string>蓝牙</string>
				<key>detail</key>
				<string>关闭</string>
	            <key>id</key>
	            <string>bluetooth</string>
			</dict>
		</array>
		<array>
			<dict>
				<key>name</key>
				<string>twitter</string>
	            <key>id</key>
	            <string>twitter</string>
			</dict>
			<dict>
				<key>name</key>
				<string>facebook</string>
	            <key>id</key>
	            <string>facebook</string>
			</dict>
		</array>
	</array>
	</plist>

###View视图
* 参见*UIView与UIViewController*部分

###Controller控制器
* 参见*UIView与UIViewController*部分

##MVVM
* 模型、视图、视图、模型，是从MVC设计模式中延伸出来的，目的是解决Controller的负担太重
* BeeFramework，作者是腾讯的技术总监
* MVVM还在发展中

##观察者模式
* 解决某一个属性发生变化时，主动通知监听者
	* `NSNotificationCenter`
	* KVO

##代理模式
* 一对一的消息传递

##单例模式
* 保证一个类在内存中只有一个实例，并且提供全局的类方法便于使用！
	* `UIApplication`
	* `NSNotificationCenter`
	* `NSFileManager`
	* `NSUserDefaults`
* 目前单例在iOS开发中已经"滥用"，在面试中，几乎都会要求手写单例
* 在OC中有两种单例模式
	* *懒汉式*，是在需要的时候在加载到内存，符合OC设计习惯
	* *饿汉式*，会在最早的时间就把单例创建好，放入内存，随时可以使用！
		* 特点：是用空间换时间
		* 好处：不需要关心加锁等问题，直接返回静态成员即可！
 		* 在iOS开发中，用的很少！
		*  `+ (void)load`只要程序运行，就会执行一次
 		* `+ (void)initialize`第一次用到类或者自类的时候，会执行一次

###ARC中单例的实现
* 步骤
	* 提供全局访问方法，公认的格式 shared+类型
	* 有一个静态全局变量，保证对象的实例保存在静态区，并且不需要关心释放的问题
	* 重写`allocWithZone`方法，能够保证对象只被实例化一次！
		* 需要包含`dispatch_once`：保证对象只被分配一次内存空间
	* 实现shared方法
		* 需要包含`dispatch_once`：保证对象只被初始化一次

>eg.h

	#import <Foundation/Foundation.h>
	@interface SoundTools : NSObject <NSCopying>
	// 全局的访问方法
	+ (instancetype)sharedSoundTools;
	@end

>eg.m

	@interface SoundTools()
	@property (nonatomic, assign) int count;
	@end
	
	@implementation SoundTools
	static id instance;
	
	// 所有对象的内存分配，最终都会调用到此方法
	// 把这个方法搞定，就能实现单例！
	+ (instancetype)allocWithZone:(struct _NSZone *)zone {
	    
	    // 问题：这种方式不是线程安全的
	    // 解决方法1：增加互斥锁
	//    @synchronized (self) {
	//        if (instance == nil) {
	//            instance = [super allocWithZone:zone];
	//        }
	//    }
	    // 其他解决办法？dispatch_once，执行一次，线程安全！
	    static dispatch_once_t onceToken;
	    dispatch_once(&onceToken, ^{
	        if (instance == nil) {
	            instance = [super allocWithZone:zone];
	        }
	    });
	    return instance;
	}
	
	+ (instancetype)sharedSoundTools {
	    static dispatch_once_t onceToken;
	    dispatch_once(&onceToken, ^{
	        // 使用shared方法只能做一次初始化！
	        instance = [[self alloc] init];
	    });
	    return instance;
	}
	
	//------------- 以上部分是面试的时候，需要手写单例的代码------
	- (id)copyWithZone:(NSZone *)zone {
	    return instance;
	}
	
	- (instancetype)init
	{
	    self = [super init];
	    if (self) {
	        _count = 10;
	        NSLog(@"初始化 %d", _count);
	    }
	    return self;
	}
	@end

###MRC中的单例的实现
* 先参考*ARC中单例的实现*部分

>eg.m增

	#pragma mark - MRC模式中需要增加的代码
	- (oneway void)release {
	    // 原本的程序是做计数－1
	}
	
	- (instancetype)retain {
	    return instance;
	}
	
	- (instancetype)autorelease {
	    return instance;
	}
	
	- (NSUInteger)retainCount {
		// retainCount返回最大整数，此方法可以不重写
	    // 出处 limits.h ULONG_MAX 宏可以自行根据运行的CPU架构调整整数的长度
	    return ULONG_MAX;
	}

###抽取单例宏

>Singleton.h

	#define singletonInterface(className) +(instancetype)shared##className;
	#if __has_feature(objc_arc)
	// 以下是ARC版本
	#define singletonImplementation(className) \
	+ (instancetype)allocWithZone:(struct _NSZone *)zone { \
	    static dispatch_once_t onceToken; \
	    dispatch_once(&onceToken, ^{ \
	        if (instance == nil) { \
	            instance = [super allocWithZone:zone]; \
	        } \
	    }); \
	    return instance; \
	} \
	+ (instancetype)shared##className { \
	    static dispatch_once_t onceToken; \
	    dispatch_once(&onceToken, ^{ \
	        instance = [[self alloc] init]; \
	    }); \
	    return instance; \
	} \
	- (id)copyWithZone:(NSZone *)zone { \
	    return instance; \
	}
	#else
	// 以下是MRC版本
	#define singletonImplementation(className) \
	+ (instancetype)allocWithZone:(struct _NSZone *)zone { \
	    static dispatch_once_t onceToken; \
	    dispatch_once(&onceToken, ^{ \
	        if (instance == nil) { \
	            instance = [super allocWithZone:zone]; \
	        } \
	    }); \
	    return instance; \
	} \
	+ (instancetype)shared##className { \
	    static dispatch_once_t onceToken; \
	        dispatch_once(&onceToken, ^{ \
	        instance = [[self alloc] init]; \
	    }); \
	    return instance; \
	} \
	- (id)copyWithZone:(NSZone *)zone { \
	    return instance; \
	} \
	- (oneway void)release {} \
	- (instancetype)retain {return instance;} \
	- (instancetype)autorelease {return instance;} \
	- (NSUInteger)retainCount {return ULONG_MAX;}
	#endif
	// 提示末尾一行不要有 \

>eg.h

	#import <Foundation/Foundation.h>
	#import "Singleton.h"
	@interface SoundTools : NSObject <NSCopying>
	// 全局的访问方法
	//+ (instancetype)sharedSoundTools;
	singletonInterface(SoundTools);
	@end

>eg.m

	#import "SoundTools.h"
	@interface SoundTools()
	/** 声音的数量 */
	@property (nonatomic, assign) int count;
	@end
	
	@implementation SoundTools
	static id instance;
	singletonImplementation(SoundTools);	
	#pragma mark - MRC 部分代码
	- (instancetype)init
	{
	    self = [super init];
	    if (self) {
	        _count = 10;
	        NSLog(@"初始化 %d", _count);
	    }
	    return self;
	}
	@end

***
#多线程
__(参见UNIX C笔记)__
##进程
* 进程对应一块内存空间

##线程
* 一个进程可以分为多个线程，一个iOS程序运行后，默认会开启一条线程，称为主线程或UI线程
* 网络开发一般使用多线程

###时间片
* 人的感知时有延迟的，CPU将时间分为人无法感知的碎片，称为时间片

###串行与并行
* 线程是串行的，通过时间片实现伪并行
* 线程调度时无序的，线程启动后的调度顺序是由CPU决定的，程序员无法参与

###线程的缺点
* 开启线程需要占用一定的内存空间，在iOS中，主线程栈区占用1MB，子线程占用512K
* 线程太多，会占用大量的内存空间，降低程序性能，CPU在调度线程上的开销越大，负荷越大

###线程的主要作用
* 显示和刷新UI界面
* 处理UI事件(比如点击事件、滚动事件、拖拽事件等)

###线程的使用注意
* 不要将耗时的操作放到主线程中，以避免主线程被阻塞，影响UI流畅度和用户体验
* 不要相信单次运行的结果

###线程安全
* 多个线程同时进行操作同一块内存时，读写的数据可能会出现问题

###互斥量(mutex)
* 为了避免多个线程同时进行操作同一块内存带来的问题，产生了互斥量的概念，也叫互斥锁、同步锁
* 使用互斥量会阻塞线程
* 加锁的代码范围要尽可能小，只要锁住资源读写部分代码即可

###信号量(semaphore)
* 信号量是一个计数器，用来控制访问共享资源的最大并行线程总数，这里的信号量也支持进程(Linux系统中目前不能用于进程)
* 当信号量的计数为1时，效果等价于互斥量

###条件变量

###线程间通信

###XSI IPC
* 共享内存、消息队列和信号量集统称为XSI IPC，遵循相同的POSIX规范
* XSI IPC的同性
	* 创建时 都需要提供一个外部key，类型`key_t`(整型)
	* key被用来参与 XSI IPC结构(共享内存、消息队列和信号量集)的创建，创建成功后每个IPC结构都有自己唯一的标识(非负整数)ID
	* 在创建IPC结构时，都需要提供结构的访问权限
	* IPC结构由内核管理，如果不手工删除，重启机器后依然占据空间
	* key的创建方式有三种
		* 宏 `IPC_PRIVATE`，但基本不用，因为私有别的进程无法获取
		* 可以把所有的key定义到一个头文件中，不会发生重复
		* 可以用 `ftok()`生成key，`ftok()`使用真实存在的路径 + 项目ID 生成key
		* IPC结构的创建/获取函数一般都是
			* `xxxget()` 参数中都有key，新建时一般都需要写上 `IPC_CREAT|权限`，返回值就是ID
	* IPC结构一般都提供了一个控制函数
		* `xxxctl()`，都提供了以下功能
		* `IPC_STAT` - 查询
		* `IPC_SET`  - 修改
		* `IPC_RMID` - 删除
	* IPC结构可以用命令查看、删除
		* `ipcs` - 查询当前有哪些IPC结构
		* `ipcrm` - 删除当前的IPC结构，需要提供ID
		* 选项
			* `-a` 所有
			* `-m` 共享内存
			* `-q` 消息队列
			* `-s` 信号量集

##多线程方法编写建议
* 首先保证一条线程工作正常
* 多线程方法需要保证自己能够独立完成所有任务
* 一般开发不建议使用任何锁

##pthread
* Unix/Linux/Windows通用，遵循PROSIX规范，在头文件中均已定义

###创建进程
* `pthread_create(pthread_t, NULL, , )`
* 成功返回0，返回错误编号

###线程状态
* `join`状态
	* `join`状态的线程会在函数返回时回收资源
* `detach`状态
	* `detach`状态的线程会在线程结束时回收资源
* 一个线程最好处于`join`或`detach`之一，否则无法确定其回收资源的时间

###取消线程
* `pthread_cancel()`
* 要取消的线程必须支持取消操作

###设置线程状态
* `pthread_setcancelstate()`

###设置取消方式
* `pthread_setcanceltype()`

###结束线程
* `return value`
* `pthread_exit()`

###等待线程
* `pthread_join()`

>pthread.c

	#include <pthread.h>	
	void* task(void* par){
		int *pi = (int *)par;
		printf("");
		if
		//pthread_exit();
		return 0;
	}
	int main(){
		pthread_t pt;
		pthread_create(&pt, NULL, task, );//成功返回0，返回错误编号
		pthread_join(pt);
		//pthread_cancel(pt);
		//pthread_setcancelstate();
		//pthread_setcanceltype();
	}
	
###互斥量
####使用步骤
* 包含头文件
* 声明
* 初始化
* 加锁
* 执行可能造成数据冲突的代码
* 解锁
* 释放互斥量的资源（销毁）

####包含头文件
	#include <pthread.h>
####声明
	pthread_mutex_t lock;
####初始化
	int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
	pthread_mutex_init(&lock,0);
	或在声明时赋值：
	pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
####加锁
	int pthread_mutex_lock(pthread_mutex_t *mutex);
	pthread_mutex_lock(&lock);
####解锁
	int pthread_mutex_unlock(pthread_mutex_t *mutex);
	pthread_mutex_unlock(&lock);
####释放互斥量的资源（销毁）
	int pthread_mutex_destroy(pthread_mutex_t *mutex);
	pthread_mutex_destroy(&lock);

###信号量
####使用步骤
* 包含头文件
* 定义信号量
* 初始化信号量
* 获取信号量（计数器减1）
* 访问资源
* 释放信号量（计数器加1）
* 回收信号量资源（销毁）

####包含头文件
	#include <semaphore.h>
####定义信号量
	sem_t sem;
####初始化信号量
	sem_init(&sem,0,5);
	sem_init(信号量指针,0代表用于线程非0用于进程,计数器最大值);
####获取信号量（计数器减1）
	sem_wait(&sem);
####访问资源
####释放信号量（计数器加1）
	sem_post(&sem);
####回收信号量资源（销毁）
	sem_destroy(&sem);

###条件变量

##NSThread
###原生方法
* 需要start方法

####number属性
* 1为主线程，否则为其他线程

####name属性
* 标识线程

####threadPriority属性
* 即线程优先级，仅表示CPU对该任务的调度会更加积极
* 范围0.0 ~ 1.0
* 默认值0.5
* 通常开发时，不要处理优先级
* 优先级反转
	* 低优先级任务阻塞CPU无法调度高优先级任务

>alloc_init

	NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:id];
	thread.name = @"Thread A";
	[thread start];

###隐式方法
* 放在后台执行

>performSelectorInBackGround:withObject:

	[obj performSelectorInBackGround:@selector() withObject:nil];

###派发任务
* 类方法指定selector方法在后台线程执行，方法会直接调度
* `[NSThread detachNewThreadSelector:@selector() toTarget:self withObject:nil]`

###获取当前线程
* `[NSThread currentThread]`
	
###线程状态
* 新建(new)
* start => 就绪状态(Runnable)
* CPU调度 => 运行(Running)
* 休眠/同步锁 => 阻塞(Blocked)
* 线程任务结束/异常/强行退出 => 死亡(Dead)

###线程休眠
* `[NSThread sleepForTimeInterval:1.0f]`
* `[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0f]]`
	
###结束线程
* 任务执行完毕，线程自然结束
* 调用`exit`/`return`方法，手动强行结束
	* 一旦结束线程，后续代码都不会执行
* `NSThread exit]`

###互斥量
* 要求是一个能够加锁的NSObject，所有的线程都能够访问到对象
* 在实际开发中，如果只抢夺一个资源，就只需要一把锁，通常使用self

>synchronized

	@synchronized (self){
		// code here...
	}

###信号量

###条件变量

###原子锁
* 类似于互斥量，但性能略高
* 在Obj-CC中定义属性时默认都是`atomic`
* 如果定义了原子属性，就不要重写`getter`和`setter`方法
* 原子锁本质上是128位自旋锁，能够实现单写多读，保证只有一个线程写入，但允许多个线程读取
* 每一种技术，只要有额外的代码，就需要CPU付出额外的代价，原子属性同样代价很高，性能不好，耗电
* 建议所有属性都声明为`nonatomic`

###线程安全
* UIKit中几乎所有对象都不是线程安全的
* 苹果约定，所有UI控件更新均在主线程中执行，从而保证UI正常显示
	* 这也是为什么主线程也称为UI线程
	* 有些情况下在其他线程更新UI也是正确的，但一定不要尝试这样的做法

###线程间通信
* `[obj performSelectorOnMainThread:@selector() : waitUntilDone:BOOL]`

##GCD
* GCD(Grand Central Dispatch，强大中枢调度器)
* GCD是C语言框架，所有GCD函数均以dispatch开头
* GCD开发时，程序员不需要管线程，而是面对*队列*开发，将需要的任务添加到不同的队列中
* GCD的优势	* GCD是苹果公司为多核的并⾏行运算提出的解决⽅方案	* GCD会⾃自动利⽤用更多的CPU内核(⽐比如双核、四核)	* GCD会⾃自动管理线程的⽣生命周期(创建线程、调度任务、销毁线程)	* 程序员只需要告诉GCD想要执⾏行什么任务，不需要编写任何线程管理代码
* MRC的GCD开发中，遇到`create`，`copy`，`retain`时需要`dispatch_release(dispatch_queue_t p)`函数释放
* ARC的GCD开发中，不需要释放

###任务
* 用block来定义
* 任务决定是否开启新线程，同步不开启新线程，异步会开启新线程

####同步任务
* 顺序执行任务
* 同步任务只有一个用处，即阻塞后面的所有任务，等待同步任务完成后再并发执行
* `dispatch_sync(dispatch_queue_t queque,^{})`

####异步任务
* 要在别的线程并发执行，会开启新的线程
* 异步是多线程的代名词
* `dispatch_async(dispatch_queue_t queque,^{})`

###队列
* 队列专门用来调度任务，安排不同的任务去不同的线程工作
* 队列决定能够开启线程的数量，串行最多一条，并发最多线程数量由GCD决定
* 队列也可以不开启线程
* 队列在调度任务时，如果正在执行的是同步任务，会等待同步任务执行完成后再调度后续的任务

####串行队列
* 顺序的队列，所有任务顺序执行，最多开启一条线程

####并发队列
* 能够开启多条线程

####主队列
* 专门用来做线程间通讯，后台线程完成工作后，通知主线程更新UI
* 主队列只能获取，不能创建
* 主队列调度任务在主线程工作，不能开启线程
* 队列调度任务是先进先出，主队列不能开启线程，那么只能顺序执行任务
* 主队列中只能使用异步任务，否则会造成死锁

####全局队列
* 全局队列在iOS 7和iOS 8中有区别
* 全局队列是方便程序员使用，可以直接使用的整个系统全局共享的队列
* 全局队列只能获取，不能创建

#####全局队列与手动并发队列
* 全局队列本质上就是并发队列，系统全局的调度队列，可以方便程序员使用
* 创建并发队列有一个好处，在大型商业应用中，通常需要跟踪具体的任务是由哪个队列调度的，如果程序闪退，会产生日志，发送给开发者，便于开发者解决问题，如果能够记录崩溃所在队列的名称，方便排错
* `dispatch_get_global_queue(long identifier,unsigned long flags)`
* 参数
	* `long identifier`
		* iOS 8中为标识符，指定队列的服务质量，QOS与XPC框架联合使用，XPC是OS X开发中用于进程间通讯的框架
			* `QOS_CLASS_UNSPECIFIED`，即0，表示没有使用QOS
		* iOS 7中为优先级
			* `DISPATCH_QUEUE_PRIORITY_HIGH`，即2，高优先级
			* `DISPATCH_QUEUE_PRIORITY_DEFAULT`，即0，默认
			* `DISPATCH_QUEUE_PRIORITY_LOW`，即-2，低优先级
			* `DISPATCH_QUEUE_PRIORITY_BACKGROUND`，即INT16_MIN，后台优先级
			* 如果使用后台优先级，工作性能会慢的令人发指
		* 传入0就可以保证iOS 7与iOS 8全局队列的适配
	* `unsigned long flags`，为未来使用保留，应该始终传入0
		
###基本使用
####使用步骤
* 定制任务	* 确定想做的事情* 将任务添加到队列中	* GCD会⾃自动将队列中的任务取出,放到对应的线程中执⾏行	* 任务的取出遵循队列的FIFO原则，即先进先出，后进后出
	
####串行队列＋同步任务
* 不会开启新线程，顺序执行所有任务
* 任务顺序执行的原因是同步任务
* 在开发中几乎不用

>queue_serial_sync

	// 队列
	dispatch_queue_t que = dispatch_queue_create("meniny",DISPATCH_QUEUE_SERIAL);
	// 让队列调度任务
	for (int i = 0;i < 10,i++){
		dispatch_sync(que, ^{
			// code here...
			NSLog(@"%@-%d",[NSThread currentThread],i);
		});
	}
	
####串行队列＋异步任务
* 开启一条新线程，*顺序*执行所有任务
* 任务顺序执行的原因是串行队列

>queue_serial_async

	// 队列
	dispatch_queue_t que = dispatch_queue_create("meniny",DISPATCH_QUEUE_SERIAL);
	// 让队列调度任务
	for (int i = 0;i < 10,i++){
		dispatch_async(que, ^{
			// code here...
			NSLog(@"%@-%d",[NSThread currentThread],i);
		});
	}

####并发队列＋异步任务
* 会开启多条线程，任务*不是*顺序执行

>queue_concurrent_async

	// 队列
	dispatch_queue_t que = dispatch_queue_create("meniny",DISPATCH_QUEUE_CONCURRENT);
	// 让队列调度任务
	for (int i = 0;i < 10,i++){
		dispatch_async(que, ^{
			// code here...
			NSLog(@"%@-%d",[NSThread currentThread],i);
		});
	}
	
####并发队列＋同步任务
* 不会开启新线程，顺序执行所有任务
* 任务顺序执行的原因是没有开启新线程

>queue_concurrent_sync

	// 队列
	dispatch_queue_t que = dispatch_queue_create("meniny",DISPATCH_QUEUE_CONCURRENT);
	// 让队列调度任务
	for (int i = 0;i < 10,i++){
		dispatch_sync(que, ^{
			// code here...
			NSLog(@"%@-%d",[NSThread currentThread],i);
		});
	}

####主队列+异步任务
* 不会开启新线程，*顺序*执行所有任务
* 任务顺序执行的原因是没有开启新线程

>main_queue_async

	// 队列
	dispatch_queue_t que = dispatch_get_main_queue();
	// 让队列调度任务
	for (int i = 0;i < 10,i++){
		dispatch_async(que, ^{
			// code here...
			NSLog(@"%@-%d",[NSThread currentThread],i);
		});
	}

####主队列+同步任务
* 不会开启新线程，会造成*死锁*

>main_queue_sync

	// 队列
	dispatch_queue_t que = dispatch_get_main_queue();
	// 让队列调度任务
	for (int i = 0;i < 10,i++){
		dispatch_sync(que, ^{
			// code here...
			NSLog(@"%@-%d",[NSThread currentThread],i);
		});
	}

####全局队列+异步任务
* 会开启多条线程，任务并发执行

>global_queue_async

	// 队列
	dispatch_queue_t que = dispatch_get_global_queue(0, 0);
	// 让队列调度任务
	for (int i = 0;i < 10,i++){
		dispatch_async(que, ^{
			// code here...
			NSLog(@"%@-%d",[NSThread currentThread],i);
		});
	}


###应用场景
####同步任务
>例：在线小说网站，需要用户登录，然后再下载小说

	dispatch_queue_t que = dispatch_queue_create("meniny",DISPATCH_QUEUE_CONCURRENT);
	// 要保证用户登录最先执行
	dispatch_async(que, ^{
		dispatch_sync(que, ^{
			NSLog(@"用户登录-%@",[NSThread currentThread]);
		}
		dispatch_async(que, ^{
			NSLog(@"下载小说 A -%@",[NSThread currentThread]);
		}
		dispatch_async(que, ^{
			NSLog(@"下载小说 B -%@",[NSThread currentThread]);
		}
	}

###队列的选择取舍
* 串行队列最多开启一条线程，任务顺序执行，效率低，执行慢，但省电
	* 对执行顺序要求高，对并发要求不高，执行性能要求不高，兼顾电量，可以选择串行队列
* 并发队列可以开启多条线程，任务并发执行，效率高，执行快，但费电
	* 对执行效率要求高，对执行顺序要求不高，可以选择并发队列

###常用GCD组合
>最常见的GCD代码

	// GCD是用来处理耗时的任务
	dispatch_async(dispatch_get_global_queue(0, 0), ^{
		// 耗时的任务
		// code here...
		// 与主线程通讯，更新UI
		dispatch_async(dispatch_get_main_queue(), ^{
			// 更新UI
			// code here...
		});
	});

###其他GCD用法
####延时处理
* `dispatch_after(dispatch_time_t when,queue , ^{})`
* `when` 延时
	* 从`DISPATCH_TIME_NOW`起经过多少纳秒后在`queue`队列上执行`block`
	* `dispatch_time(DISPATCH_TIME_NOW,延迟时间_纳秒)`
* `queue` 队列
* `block` 异步任务

>dispatch_after

	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
		NSLog(@"%@",[NSThread currentThread]);
	});
	// 全局队列会延时多少时间后新建线程执行block
	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64)(1.0 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^{
		NSLog(@"%@",[NSThread currentThread]);
	});
	// 串行队列会延时多少时间后新建线程执行block
	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64)(1.0 * NSEC_PER_SEC)), dispatch_queue_create("meniny", NULL), ^{
		NSLog(@"%@",[NSThread currentThread]);
	});

####成组工作

	dispatch_group_t gup = dispatch_group_create();
	dispatch_queue_t que = dispatch_get_global_queue(0, 0);
	// 派发任务
	dispatch_group_async(gup, que, ^{
		NSLog(@"任务一%@",[NSThread currentThread]);
	});
	dispatch_group_async(gup, que, ^{
		NSLog(@"任务二%@",[NSThread currentThread]);
	});
	dispatch_group_async(gup, que, ^{
		NSLog(@"任务三%@",[NSThread currentThread]);
	});
	
	dispatch_group_notify(gup, dispatch_get_main_queue(), ^{
		NSLog(@"任务全部完成%@",[NSThread currentThread]);
	});
	
####单次执行
* 有些代码只希望执行一次，应用最广泛的是单例设计模式
* `dispatch_once()`是线程安全的，在多线程执行的时候仍可以保证只执行一次，它同样使用了锁，而性能比互斥锁高很多，这是苹果推荐的技术，但目前已经达到了滥用的程度

>dispatch_once

	static dispatch_once_t onceToken;
	NSLog(@"%ld",onceToken);
	dispatch_once(&onceToken, ^{
		// 只执行一次的代码
		// code here...
	});

##NSOperation
* NSOperation是抽象类，并不具备封装操作的能⼒力,必须使⽤用它的⼦子类
	* 使⽤用NSOperation子类的方式有3种		* NSInvocationOperation
		* NSBlockOperation		* 自定义⼦子类继承NSOperation,实现内部相应的⽅方法
* 配合NSOperation和NSOperationQueue也可以实现多线程
* NSOperation & GCD属于并发开发
* 程序猿只需要面对队列，将操作添加到队列上即可，不用关心线程，也不用关心线程状态
* NSOperation & GCD一般都不需要我们添加自动释放池
* NSOperation是对GCD的封装
* 历史
	* NSOperation是iOS 2出现，GCD在iOS 4出现
	* 苹果对NSOperation基于GCD面向对象封装

###NSOperation和NSOperationQueue实现多线程的具体步骤
* 先将需要执⾏行的操作封装到⼀个NSOperation对象中* 然后将NSOperation对象添加到NSOperationQueue中* 系统会⾃自动将NSOperationQueue中的NSOperation取出来

###NSOperationQueue
* 实例化的NSOperationQueue本质上就是GCD的全局队列
* 添加到队列中的操作都是异步执行的

>NSOperationQueue

	NSOperationQueue *queue = [[NSOperationQueue alloc] init];
	[queue addOperation:op];

>NSOperationQueue mainQueue

	[[NSOperationQueue mainQueue] addOperationWithBlock:^{
		// upd UI...
	}];

* 通常开发中，会使用一个全局队列来管理

>NSOperationQueue

	@property (nonatomic, strong) NSOperationQueue *opQueue;
	
	- (NSOperationQueue *)opQueue {
		if (!_opQueue) {
			_opQueue = [[NSOperationQueue alloc] init];
		}
		return _opQueue;
	}

###并发线程数
* 在iOS 7中，使用NSOperation或GCD一般只能开启10条左右的线程
* 从iOS 8开始，如果任务很多，线程数量同样很大
* 开启线程是有消耗的，实际开发中有必要控制同时并发的线程数量，这个控制在GCD中较难实现
* `maxConcurrentOperationCount:(NSInteger)`最大并发线程数，设定最大并发线程数
* 在GCD底层为了提高程序并发性能，会维护一个线程池，供所有应用程序的多线程使用，每个线程上的任务执行后，会被GCD线程池回收，而不销毁
* 在队列调度任务时，会出现任务执行完毕，但底层线程池还没有完全回收，如果在调度其他任务，系统会从线程池中取出一个空线程供程序使用

####何时需要控制最大并发线程数？
* 下载网络资源，判断用户联网状态
	* WI-FI：不花钱，能够随时充电，可以让线程数5-6，并发性能好，速度快
	* 3G：花钱，不容易充电，可以让线程数少一些，2-3，速度慢

###队列暂停与继续调度任务
* `op.suspended = YES`挂起，设定`YES`或`NO`
* `operationCount`操作数，返回当前操作数
* 如果队列已经调度了任务，挂起操作不会对任务造成影响，任务仍然会继续执行
* 如果任务没有执行完毕，会包含在operationCount中
* 任务执行完成后，队列中的任务技术才会变化

####应用场景
* TableView滚动时需要暂停队列的下载，而停止滚动，需要让队列继续下载，这样可以避免很多无谓的网络请求

###依赖
* 在GCD中可以通过同步任务要求任务执行的顺序，而NSOperation中只有异步任务
* `[op2 addDependency:op1]`指定任务之间的依赖关系，op2需要等op1执行完毕后才可以执行
* 多个任务之间，可以跨队列依赖
* 注意，线程依赖关系*不能循环*，否则会造成死锁

####应用场景
* 网络下载小说的压缩包
* 解压缩保存到磁盘
* 通知用户可以阅读

###NSInvocationOperation
* `[op start]`
	* 调用start方法后会自动执行target的selector方法
	* 不会创建新线程，默认在当前线程同步执行操作
* 只有添加NSOperation到NSOperationQueue才会异步执行

>NSInvocationOperation & start

	NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector() object:@"hello"];
	[op start];

>NSInvocationOperation & NSOperationQueue

	NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector() object:@"hello"];
	NSOperationQueue *queue = [[NSOperationQueue alloc] init];
	[queue addOperation:op];

###NSBlockOperation
* `- (void)blockOperationWithBlock:(void (^)(void))block`初始化并添加操作
* `- (void)addExecutionBlock:(void (^)(void))block`添加更多操作

>NSBlockOperation

	NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
		// code here...
	}];
	NSOperationQueue *queue = [[NSOperationQueue alloc] init];
	[queue addOperation:op];

>NSBlockOperation

	NSOperationQueue *queue = [[NSOperationQueue alloc] init];
	[queue addOperationWithBlock:^{
		// code here...
		[[NSOperationQueue mainQueue] addOperationWithBlock:^{
			// udp UI
		}];	
	}];

###自定义子类继承NSOperation类，实现相应方法

##GCD对比NSOperation
###CGD
* GCD时C语言的
* 两个队列，两种任务，需要排列组合
* 一次性、分组、延迟等功能时NSOperation不具备的

###NSOperation
* NSOperation是Obj-C的
* NSOperation是对GCD的封装
* 新创建的队列就是并发队列，添加到队列中的任务就是异步执行
* 可以设置最大并发数、暂停与继续使用起来比GCD方便
* 可以指定队列之间的依赖关系，代码结构上直观

###提示
* 国内大部分公司在使用GCD，很少使用NSOperation
* 苹果强烈建议使用NSOperation，从iOS 8开始，GCD底层调度的线程数量从原有的10以内增加到70以上(测试结果)

#网络
##网络加载图片的具体实现
* 同步加载图片问题：如果网络速度不好，会产生延迟，造成卡顿感觉
	* 解决方法：使用多线程异步加载图片，完成后刷新表格
* 新问题：图像默认不显示，需要滚动刷新之后才能显示
	* 解决办法：使用占位图像
* 如果滚动快，网络下载来不及更新，会出现多个下载完成后更新同一个cell的情况
* 一次都需要从网络上加载图片
* 这些问题使用SDWebImage框架，只需要一句代码即可解决

##Apache
* 目的:有一个自己专属的测试环境
	* 新建目录存放网页(不要放在Desktop或Documents里)
	* 修改Apache配置文件httpd.conf
		* `vi /etc/apache2/httpd.conf`
		`/DocumentRoot `
		`Indexes`
		`php5`
		* 10.10中需要增加一个属性
		* 支持PHP
		* `cp /etc/http.ini.default /etc/php.ini`

##PHP

##UIWebView

##XML
* 可扩展标记语言
* 区分大小写
* 命名不能以`xml`(`XML`、`Xml`...)、数字、下划线开头，不能出现冒号
* `<?xml version="1.0" standalone="no" encoding="UTF-8"?>`
* W3C认证，IBM & Microsoft联合推广
* 能够解决所有异构数据库系统之间的数据传递

###DTD
* 验证XML元素是否符合规范

>

	<!DOCTYPE myfile = [
		<!ELEMENT name (#PCDATA)>
	]
	>
	
###元素
* `<name>Bill</name>`

###属性
* `<name color="red">Bill</name>`中`color="red"`

###注释
* `<!--`起始
* `-->`结束

###验证

###解析
####NSXMLParser
* 需要遵守`<NSXMLParserDelegate>`协议

>parser

	NSXMLParser *parser = [[NSXMLParser alloc] initWithData:data];
	parser.delegate = self;
	[parser parser];

* 开始解析文档，做一些准备工作
	* `- (void)parserDidStartDocument:(NSXMLParser *)parser {}`

* 找到元素
	* `- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementNam namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attribute {}`

* 找到元素内容
	* `- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string {}`

* 元素结束
	* `- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName {}`

* 结束文档解析，通常做一些收尾工作，就可以更新UI了
	* `- (void)parserDidEndDocument:(NSXMLParser *)parser {}`

* 在网络处理中通常需要做相应的错误处理
	* `- (void)parser:(NSXMLParser *)parser `

>\b<[1]{a-z0-9}+\s?{a-z0-9}*\=?"?{a-z0-9}*"?>[1]\w+<[1]/[1]{a-z0-9}+>[1]\b


###SAX

###DOM

##JSON
* 标记语言
* 采用了Java Script语法，可以直接解析JS中的JSON数据

###键
* key值

###值
* value值
* 键与值之间用`:`分隔

####对象
* `{"name":"Bill","age":"20"}`
* 等价于Java Script中的：
	`name = "Bill"`
	`age = "20"`

####数组
* `["name","age","obj"{"title":"someobj"}]`

####字符串
* `"some String"`

####数字
* 包括整型与浮点型

####逻辑值
* `true`和`false`

####null
* 空

###键值对
* `key:value`
* 多个键值对之间用`,`分隔

##URL
* URL的全称是Uniform Resource Locator(统⼀资源定位符)
* 通过一个URL，能找到互联⽹上唯⼀的一个资源，依赖于网络资源，不能随意更改* URL就是资源的地址、位置，互联⽹上的每个资源都有一个唯一的URL* URL的基本格式 = 协议:`//主机地址/路径`###协议
* 不同的协议，代表着不同的资源查找⽅方式、资源传输⽅方式###主机地址* 存放资源的主机的IP地址(域名)
###路径
* 资源在主机中的具体位置
###URL中常见的协议####HTTP* 超⽂文本传输协议，访问的是远程的网络资源，格式是`http://`* http协议是在⽹网络开发中最常⽤用的协议####file* 访问的是本地计算机上的资源，格式是`file://`(不⽤用加主机地址)####mailto* 访问的是电⼦子邮件地址，格式是`mailto:`####FTP* 访问的是共享主机的⽂文件资源，格式是`ftp://`
###HTTP协议简介* 不管是移动客户端还是PC端,访问远程的⽹网络资源经常使⽤用HTTP协议	* 访问百度主页:http://www.baidu.com	* 获得新浪的微博数据	* 获得⼤大众点评的团购数据* HTTP的全称是Hypertext Transfer Protocol，超⽂文本传输协议	* 规定客户端和服务器之间的数据传输格式	* 让客户端和服务器能有效地进⾏行数据沟通
* 特点	* 因为HTTP协议简单，所以HTTP服务器的程序规模⼩小，因⽽而通信速度很快	* HTTP允许传输任意类型的数据* HTTP 0.9和1.0使⽤用⾮非持续连接，限制每次连接只处理⼀一个请求，服务器对客户端的请求做出响应后，马上断开连接，这种⽅方式可以节省传输时间###HTTP通信* 请求
	* 客户端向服务器索要数据 实作* 响应
	* 服务器返回客户端相应的数据###iOS常见发送HTTP请求的方案* 苹果原⽣生(⾃带)	* `NSURLConnection`
		* ⽤用法简单，最古⽼老最经典最直接的一种方案	* `NSURLSession`
		* iOS 7新出的技术，功能⽐比NSURLConnection更加强⼤大
	* `CFNetwork`
		* NSURL*的底层，纯C语⾔* 第三⽅方框架 
	* ASIHttpRequest
		* 外号“HTTP终结者”，功能极其强⼤大，可惜早已停止更新	* AFNetworking		* 简单易⽤用，提供了基本够⽤用的常⽤用功能，维护和使⽤用者多	* MKNetworkKit		* 简单易⽤用，产⾃印度，维护和使⽤用者少* 为了提⾼高开发效率，企业开发⽤用的基本是第三⽅框架 
* ASI和AFN架构对⽐###发送HTTP请求的方法* 在HTTP/1.1协议中，定义了8种发送HTTP请求的⽅法	* `GET`
	* `POST`
	* `OPTIONS`
	* `HEAD`
	* `PUT`
	* `DELETE`
	* `TRACE`
	* `CONNECT`
	* `PATCH`* 根据HTTP协议的设计初衷，不同的方法对资源有不同的操作⽅式	* PUT:增	* DELETE:删	* POST:改	* GET:查* 最常⽤的是GET和POST(实际上GET和POST都能办到增删改查)* 要想使用GET和POST请求跟服务器进⾏行交互，得先了解⼀个概念* 参数	* 就是传递给服务器的具体数据，⽐如登录时的帐号、密码####GET和POST对⽐* GET和POST的主要区别表现在数据传递上
* GET	* 在请求URL后面以`?`的形式跟上发给服务器的参数，`＝`后面跟上值，多个参数之间⽤`&`隔开，⽐如		* `http://ww.test.com/login?username=123&pwd=234&type=JSON`	* 由于浏览器和服务器对URL长度有限制，因此在URL后⾯面附带的参数是有限制的，通常不能超过1KB* POST	* `HTTPMethod = @"POST";`默认为GET	* 只是从服务器拿数据，URL中不需要发送任何额外信息	* 发给服务器的参数全部放在请求体中		* `HTTPBody = [NSString stringWithFormat:@"username=aaa&pwd=bbb",username,pwd];`	* 理论上，POST传递的数据量没有限制(具体还得看服务器的处理能⼒)

####GET和POST的选择* 如果要传递⼤大量数据，⽐比如⽂文件上传，只能⽤用POST请求* GET的安全性⽐比POST要差些，如果包含机密、敏感信息，建议⽤POST* 如果仅仅是索取数据(数据查询)，建议使⽤用GET* 如果是增加、修改、删除数据，建议使⽤用POST###序列化
* 要将程序中使用的对象发送给服务器之前，转换为二进制数据的过程，将对象转换为0101类型的数据，就能够在网络上传输了

###反序列化
* 将从服务器获取到的二进制数据转换为OC对象的过程，将0101类型的数据

###JSON解析
* 将特殊格式的字符串(NSData)直接转换为NSArray或者NSDictionary
* 苹果原生
	* `NSJSONSerialization`性能最好
	
	* 选项参数
		* `NSJSONReadingMutableContainers = 1`
		* `NSJSONReadingMutableLeaves = (1UL << 1)`
		* `NSJSONReadingAllowFragments = (1UL << 2)`

* 第三方框架
	* `JSONKit`性能最好
	* `SBJson`性能中等
	* `TouchJSON`性能略差###HTTP通信过程(请求)* HTTP协议规定，一个完整的由客户端发给服务器的HTTP请求中包含以下内容	* 请求⾏行		* 包含了请求⽅方法、请求资源路径、HTTP协议版本			* `GET /MJServer/resources/images/1.jpg HTTP/1.1`	* 请求头		* 包含了对客户端的环境描述、客户端请求的主机地址等信息			* `Host: 192.168.1.105:8080 // 客户端想访问的服务器主机地址`			* `User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9) Firefox/30.0 // 客户端的类型，客户端的软件环境`			* `Accept: text/html， */* // 客户端所能接收的数据类型`			* Accept-Language: zh-cn // 客户端的语⾔言环境`			* `Accept-Encoding: gzip // 客户端⽀支持的数据压缩格式`	* 请求体		* 客户端发给服务器的具体数据，⽐比如⽂文件数据###HTTP通信过程(响应)* 客户端向服务器发送请求，服务器应当做出响应，即返回数据给客户端* HTTP协议规定，一个完整的HTTP响应中包含以下内容	* 状态⾏行		* 包含了HTTP协议版本、状态码、状态英⽂文名称			* `HTTP/1.1 200 OK`	* 响应头
		* 包含了对服务器的描述、对返回数据的描述			* `Server: Apache-Coyote/1.1 // 服务器的类型`			* `Content-Type: image/jpeg  // 返回数据的类型`			* `Content-Length: 56811 // 返回数据的长度`			* `Date: Mon,23 Jun 2014 12:54:52 GMT // 响应的时间`
	* 实体内容:服务器返回给客户端的具体数据，⽐如⽂件数据

***
#正则表达式
##元字符
* 元字符即保留字、关键字
* `*`
* `?`
* `+`
* `\`
* `.`
* `\b`字母开头或结尾
* `\d`
* `\w`字母、数字、下划线、汉字等
* `\s`任意空字符()
* `(`
* `)`
* `[`
* `]`
* `{`
* `}`
* `|`
* `\B`非字母开头或结尾
* `\D`
* `\W`非字母、数字、下划线、汉字等
* `\S`非空字符
* `^`字符串开头
* `$`字符串结尾

##重复
* `*`重复零次或多次
* `?`重复零次或一次
* `+`重复一次或多次
* `{2}`重复两次
* `{0-}`重复零次或多次
* `{0-9}`重复零次至九次

##字符转意
* 当需要查找元字符时，使用转意符
* 在元字符前面添加`\`

##分支
* 分支即判断，多个表达式之间用`|`连接即可组成一个分支，从左到右依次判断，只需匹配其中之一，后面的会被忽略
* `/b0{1}[0-9]{3}-?[0-9]{7}/b`

##分组
* `[a]`字符a
* `[aeiou]`字符a、e、i、o、u
* `[0-9]`数字0至9
* `[a-z0-9A-Z]`字母a至z、数字0至9和字母A至Z


***
###<center>Powered by [Meniny](http://weibo.com/Meniny)</center>
<center>Contact <Meniny@qq.com></center>

